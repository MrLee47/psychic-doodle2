<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronicles of Heroes: Visualized Combat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    
    <!-- CONSOLIDATED STYLES -->
    <style>
        /* -------------------------------------------------------------------------- */
        /* THEME DEFINITIONS */
        /* -------------------------------------------------------------------------- */

        /* Default (Cream/Fantasy) Theme */
        .default-theme {
            --bg-color: #f7f3e8; /* Cream background */
            --primary-color: #4a2d1e; /* Dark earth tone */
            --text-color: #333;
            --border-color: #8c735d;
            --button-bg: #8c735d;
            --button-hover-bg: #b1937e;
            --status-bar-bg: #e2eaf0;
            --hp-color: #d13d3d;
            --hp-bg: #f5caca;
            --mp-color: #3b82f6; /* Blue */
            --log-special: #047857; /* Darker Green highlight */
            --log-win: #059669; /* Darker Green */
            --log-loss: #b91c1c; /* Dark Red */
            --log-damage: #b45309; /* Dark Orange for damage */
            --arena-bg: #ede9d7;
            font-family: 'Inter', sans-serif;
        }

        /* Retro (Green/Terminal) Theme */
        .retro-theme {
            --bg-color: #1a1a1a;
            --primary-color: #00ff41; /* Neon green */
            --text-color: #00ff41;
            --border-color: #008020;
            --button-bg: #006400;
            --button-hover-bg: #00b300;
            --status-bar-bg: #0a0a0a;
            --hp-color: #ff0000;
            --hp-bg: #330000;
            --mp-color: #00ffff; /* Cyan */
            --log-special: #ffff00; /* Yellow */
            --log-win: #00ff41;
            --log-loss: #ff0000;
            --log-damage: #ff8c00; /* Dark orange */
            --arena-bg: #050505;
            font-family: 'Monospace', monospace;
        }

        /* General Styles */
        * {
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow-x: hidden;
            font-size: 16px;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
        }

        .hidden { display: none !important; }

        /* Card and Container Styles */
        .main-container {
            max-width: 1200px;
            width: 100%;
            height: 90vh;
            display: grid;
            grid-template-columns: 2fr 1fr; 
            gap: 20px;
        }

        /* The Visual Arena (Left Slot) */
        #visual-arena {
            background-color: var(--arena-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 10px; /* Reduced padding to make room for dialogue */
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Animation Container */
        #roll-animation-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 20px;
            min-height: 400px;
        }

        .visual-placeholder {
            font-size: 1.5rem;
            color: var(--primary-color);
            opacity: 0.6;
            text-align: center;
        }
        
        /* Combat Panel (Right Side) */
        #combat-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background-color: var(--status-bar-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Dialogue Area Styles */
        #dialogue-area {
            background-color: var(--status-bar-bg);
            border-top: 2px solid var(--border-color);
            border-radius: 0 0 10px 10px;
            padding: 15px;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #room-description {
            font-size: 1.1em;
            margin-bottom: 10px;
            font-style: italic;
        }
        #room-options {
            display: flex;
            gap: 10px;
            justify-content: flex-start;
        }
        
        /* Responsive adjustments for smaller screens */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
                height: auto;
                overflow-y: auto;
            }
            #visual-arena {
                min-height: 400px;
            }
            body {
                padding: 10px;
                height: auto;
            }
        }
        
        /* Custom Animation Elements */

        /* Slot Machine (Dice Roll) */
        .slot-machine-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 3rem;
            font-weight: 900;
            color: white;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--primary-color);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .slot-wheel {
            width: 80px;
            height: 80px;
            background-color: #333;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: 4px solid var(--border-color);
        }

        .slot-result {
            font-size: 4rem;
            color: var(--hp-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* Spinning Animation */
        @keyframes spin-roll {
            0% { transform: translateY(0); }
            100% { transform: translateY(-1000%); }
        }

        .slot-spinning {
            animation: spin-roll 0.1s linear infinite;
        }

        /* Coin Flip Visualizer */
        .coin-visualizer {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .coin {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .coin-head { background-color: gold; color: #333; }
        .coin-tail { background-color: silver; color: #333; }
        
        /* Flip Animation */
        @keyframes flip-animation {
            0% { transform: rotateY(0) scale(1); }
            50% { transform: rotateY(900deg) scale(1.2); }
            100% { transform: rotateY(0) scale(1); }
        }
        .coin-flipping {
            animation: flip-animation 1s ease-out;
        }

        /* Clash Animation */
        .clash-contester {
            font-size: 2.5rem;
            padding: 10px 20px;
            border-radius: 10px;
            margin: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        .clash-player { background-color: var(--mp-color); color: white; }
        .clash-enemy { background-color: var(--hp-color); color: white; }

        .clash-winner {
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 8px 15px var(--log-win);
        }
        .clash-loser {
            opacity: 0.4;
        }

        /* Standard Button Styles (Applied to existing elements) */
        button {
            background-color: var(--button-bg);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
        }
        button:disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }

    </style>
</head>
<body class="default-theme flex-col">

    <!-- Menu Screen (Rest unchanged) -->
    <div id="menu-screen" class="min-h-screen flex flex-col items-center justify-center p-4 w-full">
        <div class="container w-full max-w-sm text-center card">
            <h1 class="text-5xl font-extrabold mb-8">Chronicles of Heroes</h1>
            <div class="space-y-4">
                <button id="new-game-btn" class="w-64">New Game</button>
                <button id="load-game-btn" class="w-64" disabled>Load Game</button>
                <button id="open-settings-menu-btn" class="w-64">Settings</button>
            </div>
        </div>
    </div>

    <!-- Character Select Screen (Rest unchanged) -->
    <div id="character-select-screen" class="hidden min-h-screen flex flex-col items-center p-4 w-full">
        <div class="container w-full max-w-4xl card">
            <h2 class="text-3xl mt-4 mb-6">Select Your Hero</h2>
            <div id="char-select-cards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 w-full">
                <!-- Character Cards Rendered Here -->
            </div>
        </div>
    </div>

    <!-- Combat Arena - Now uses the main-container grid -->
    <div id="game-container" class="hidden main-container">
        
        <!-- VISUAL ARENA (Left Column) -->
        <div id="visual-arena">
            
            <!-- Animation Container for Rolls, Flips, Clashes -->
            <div id="roll-animation-container">
                <div class="visual-placeholder">
                    Visual Arena for Clash and Dice/Coin Animations.
                </div>
                <!-- Content will be dynamically inserted here -->
            </div>
            
            <!-- Dialogue/Room Description Area (NEW) -->
            <div id="dialogue-area" class="card">
                <p id="room-description" class="text-color text-lg mb-4"></p>
                <div id="room-options" class="flex gap-4">
                    <!-- Options buttons will be dynamically inserted here -->
                </div>
            </div>
        </div>
        
        <!-- COMBAT PANEL (Right Column) - Consolidated Game UI (Rest unchanged) -->
        <div id="combat-panel">
            
            <!-- Status Bars -->
            <div class="flex justify-between space-x-4">
                <!-- Player Status -->
                <div class="w-1/2 card">
                    <h3 id="player-name" class="text-xl mb-2">Player</h3>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%;"></div>
                    </div>
                    <p id="player-hp-text" class="hp-text">100/100</p>
                    <p id="player-status-text" class="status-text italic"></p>
                </div>

                <!-- Enemy Status -->
                <div class="w-1/2 card">
                    <h3 id="enemy-name" class="text-xl mb-2 text-right">Enemy</h3>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%;"></div>
                    </div>
                    <p id="enemy-hp-text" class="hp-text">80/80</p>
                    <p id="enemy-status-text" class="status-text italic"></p>
                </div>
            </div>

            <!-- Combat Log -->
            <div class="card flex-grow" style="min-height: 250px;">
                <h4 class="text-lg font-semibold mb-2">Combat Log (Turn: <span id="turn-counter">1</span>)</h4>
                <div id="combat-log">
                    <!-- Log entries here -->
                </div>
            </div>

            <!-- Action Panel -->
            <div class="card">
                <h4 id="dialogue-text" class="text-lg font-semibold mb-4 text-center">Choose your action:</h4>
                <div id="action-buttons" class="flex flex-wrap gap-3 justify-center">
                    <!-- Buttons rendered here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Panel (Rest unchanged) -->
    <div id="settings-panel" class="settings-panel">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-2xl font-bold">Settings</h3>
            <button id="close-settings-btn" class="close-btn">&times;</button>
        </div>
        <div class="theme-selector">
            <h4 class="text-lg font-semibold mb-3">Theme Selection</h4>
            <button class="theme-option-btn" data-theme="default">Default (Cream)</button>
            <button class="theme-option-btn" data-theme="retro">Retro (Green Terminal)</button>
        </div>
    </div>

    <script>
        /* -------------------------------------------------------\
           Chronicles of Heroes: Consolidated & Modular Core
           ------------------------------------------------------- */

        // ----------------- GLOBAL STATE -----------------
        const gameState = {
            isGameStarted: false,
            currentView: 'menu',
            player: null,
            enemy: null,
            currentTheme: 'default',
            turn: 1,
            playerAction: null,
            enemyAction: null,
            isResolving: false, // Prevents multiple turns
        };

        // ----------------- DOM REFS -----------------
        const $ = (id) => document.getElementById(id);
        const body = document.body;
        const menuScreen = $('menu-screen');
        const gameContainer = $('game-container');
        const charSelectScreen = $('character-select-screen');

        const newGameBtn = $('new-game-btn');
        const loadGameBtn = $('load-game-btn');
        const openSettingsBtn = $('open-settings-menu-btn');
        const settingsPanel = $('settings-panel');
        const closeSettingsBtn = $('close-settings-btn');
        const themeOptionBtns = document.querySelectorAll('.theme-option-btn');

        const dialogueText = $('dialogue-text');
        const actionButtonsDiv = $('action-buttons');
        const combatLog = $('combat-log');
        const turnCounter = $('turn-counter');
        
        const rollAnimationContainer = $('roll-animation-container');
        const roomDescriptionDiv = $('room-description');
        const roomOptionsDiv = $('room-options');


        const playerStatus = {
            name: $('player-name'),
            hpBar: $('player-hp-bar'),
            hpText: $('player-hp-text'),
            statusText: $('player-status-text'),
        };
        const enemyStatus = {
            name: $('enemy-name'),
            hpBar: $('enemy-hp-bar'),
            hpText: $('enemy-hp-text'),
            statusText: $('enemy-status-text'),
        };

        // ----------------- UTILITIES -----------------
        const rollDie = (max) => Math.floor(Math.random() * max) + 1;
        const rollCoins = (count) => Array.from({ length: count }, () => Math.random() < 0.5 ? 1 : 0)
                                        .reduce((a,b)=>a+b, 0);

        const delayExecution = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function log(message, className='log-entry') {
            const p = document.createElement('p');
            p.className = `log-entry ${className}`;
            p.textContent = message;
            combatLog.prepend(p);
            while(combatLog.children.length > 50) combatLog.removeChild(combatLog.lastChild);
        }

        // ----------------- CONSOLIDATED CHARACTER DATA (Simplified/Moved) -----------------
        // In a full application, this would be in a separate file, but kept here for the single-file mandate.

        const Characters = [
            // --- 1. Striker (Slow Start: Coin Scaler) ---
            {
                id: 'striker',
                name: 'Striker',
                description: 'A damage specialist who scales in power the longer a fight lasts.',
                baseStats: { maxHP: 110, defense: 2, level: 1, speed: 3, consecutive_rounds: 0, effects: [] },
                uniquePassive: { name: 'Slow Start', effect: 'Each consecutive combat round, gains +1 Coin to all attacks.', type: 'CoinScaler', onClashRoll: 'getStrikerClashBonus', onTurnEnd: 'onStrikerTurnEnd' },
                abilities: [
                    { name: 'Dragon Strike', type: 'ATTACK', damageType: 'Force', baseAttack: 4, dice: 4, coins: 2 },
                    { name: 'Heavy Blow', type: 'ATTACK', damageType: 'Physical', baseAttack: 10, dice: 12, coins: 0, statusApplied: 'Stagger' }
                ]
            },
            // --- 2. Balter (Wrestling Powerhouse) ---
            {
                id: 'balter',
                name: 'Balter',
                description: 'A wrestling powerhouse who locks down targets for massive damage.',
                baseStats: { maxHP: 130, defense: 3, level: 1, speed: 1, grappleDie: 8, isGrappling: false, effects: [] },
                uniquePassive: { name: 'The Old One, Two', effect: 'Roll an extra d4 damage on any successful clash.', type: 'ClashWinBonus', onClashWin: 'getBalterClashWinBonus' },
                abilities: [
                    { name: 'Haymaker', type: 'ATTACK', damageType: 'Blunt', baseAttack: 7, dice: 10, coins: 1 },
                    { name: 'Grapple', type: 'SPECIAL', effect: 'Roll d10 vs target\'s d8. On success, applies Grappled status.', effectHandler: 'executeGrapple', dice: 10, coins: 0, statusApplied: 'Grappled' },
                    { name: 'Piledriver', type: 'ATTACK', damageType: 'Physical', baseAttack: 12, dice: 12, coins: 0, requiredTargetStatus: 'Grappled', postExecutionHandler: 'removeGrappleStatus' }
                ]
            },
            // --- 3. Shuten-Maru (Chrono-Fist) ---
            {
                id: 'shutenmaru',
                name: 'Shuten-Maru',
                description: 'A swift, ghostly fighter who converts damage taken into healing.',
                baseStats: { maxHP: 100, defense: 1, level: 1, speed: 4, lastDamageTaken: 0, effects: [] },
                uniquePassive: { name: 'Chrono-Fist', effect: 'If an attack die roll is 8, heal for the damage taken in the previous turn.', type: 'RollTrigger' },
                abilities: [
                    { name: 'Ghost Fist', type: 'ATTACK', damageType: 'Psychic', baseAttack: 6, dice: 8, coins: 1, postDamageHandler: 'checkShutenMaruHeal' },
                    { name: 'Phase', type: 'DEFENSE', effect: 'Negates the next incoming hit.', effectHandler: 'applyNegateHit', baseAttack: 0, dice: 0, coins: 0 }
                ]
            },
            // --- 4. Zectus Maximus (Tri-Sword) ---
            {
                id: 'zectus',
                name: 'Zectus Maximus',
                description: 'A versatile warrior whose damage type changes with his weapon form.',
                baseStats: { maxHP: 105, defense: 2, level: 1, speed: 2, effects: [], gender: 'Male', triSwordState: 'Scythe' },
                uniquePassive: { name: 'Homogenous', effect: 'Adds +2 Coins to Clashes against female opponents.', type: 'ConditionalCoin', condition: { target_gender: 'Female' }, onClashRoll: 'getZectusClashBonus' },
                abilities: [
                    { name: 'Cycle', type: 'SWITCH', effect: 'Cycles Tri-Sword: Scythe -> Trident -> Hammer. Deals 2 damage on activation.', effectHandler: 'cycleTriSword', baseAttack: 2, dice: 0, coins: 0 },
                    { name: 'Tri-Sword: Main Attack', id: 'tri_sword_main', type: 'DYNAMIC_ATTACK', resolver: 'resolveZectusDynamicAttack', dice: 8, coins: 1, isZectusMainAttack: true },
                ]
            },
        ];

        // Enemy Template
        const ENEMY_GOBLIN = {
            id:'goblin', name:'Gravel-Claw Goblin', description: 'A basic enemy with a simple attack and defense.',
            baseStats:{ maxHP: 80, currentHP: 80, defense: 2, speed: 2, status:'Alive', effects: [], grappleDie: 6, gender:'Female' },
            abilities:[
                { name:'Gnaw Attack', type:'ATTACK', baseAttack:5, dice:6, coins:2, damageType:'Physical' },
                { name:'Defensive Crouch', type:'DEFENSE', effectHandler:'applyDefenseBonus', baseAttack:0, dice:0, coins:0 }
            ]
        };

        // ----------------- ANIMATION/VISUAL MODULE -----------------
        const Visuals = {
            async showSlotMachineRoll(diceSize, result, label) {
                rollAnimationContainer.innerHTML = '';
                await Visuals.setDialogue(`Rolling a d${diceSize} for ${label}...`);

                const container = document.createElement('div');
                container.className = 'slot-machine-container';
                container.innerHTML = `<p class="text-xl font-bold mb-2">${label} (d${diceSize})</p>`;

                const wheel = document.createElement('div');
                wheel.className = 'slot-wheel flex justify-center items-center';

                const resultDisplay = document.createElement('div');
                resultDisplay.className = 'slot-result slot-spinning';
                resultDisplay.textContent = '...';
                
                wheel.appendChild(resultDisplay);
                container.appendChild(wheel);
                rollAnimationContainer.appendChild(container);

                await delayExecution(1500); // Animation Spin time

                resultDisplay.classList.remove('slot-spinning');
                resultDisplay.textContent = result;
                resultDisplay.style.color = 'var(--log-damage)';

                await delayExecution(1000); // Result display time
            },

            async showCoinFlips(coinCount, result) {
                if (coinCount === 0) return;
                
                rollAnimationContainer.innerHTML = '';
                await Visuals.setDialogue(`Flipping ${coinCount} coin(s) for bonus damage...`);

                const container = document.createElement('div');
                container.className = 'flex flex-col items-center';
                container.innerHTML = `<p class="text-lg font-bold mb-2">Coin Bonus: +${result}</p>`;
                
                const visualizer = document.createElement('div');
                visualizer.className = 'coin-visualizer';

                // Simple visualization: show the final result
                for (let i = 0; i < coinCount; i++) {
                    const coin = document.createElement('div');
                    const isHead = i < result;
                    coin.className = `coin coin-flipping ${isHead ? 'coin-head' : 'coin-tail'}`;
                    coin.textContent = isHead ? 'H' : 'T';
                    coin.style.animationDelay = `${i * 0.2}s`;
                    visualizer.appendChild(coin);
                }
                
                container.appendChild(visualizer);
                rollAnimationContainer.appendChild(container);

                await delayExecution(2000 + coinCount * 200); // Wait for flips
            },

            async showClashAnimation(pRoll, eRoll) {
                rollAnimationContainer.innerHTML = '';
                await Visuals.setDialogue('Contesting the Clash...');

                const container = document.createElement('div');
                container.className = 'flex flex-col items-center justify-center space-y-4';
                
                const pContester = document.createElement('div');
                pContester.className = 'clash-contester clash-player';
                pContester.textContent = `${gameState.player.name}: ${pRoll}`;

                const eContester = document.createElement('div');
                eContester.className = 'clash-contester clash-enemy';
                eContester.textContent = `${gameState.enemy.name}: ${eRoll}`;
                
                const winner = pRoll >= eRoll ? pContester : eContester;
                const loser = pRoll >= eRoll ? eContester : pContester;

                container.appendChild(pContester);
                container.appendChild(document.createElement('p')).textContent = 'VS';
                container.appendChild(eContester);
                
                rollAnimationContainer.appendChild(container);

                await delayExecution(1000);

                winner.classList.add('clash-winner');
                loser.classList.add('clash-loser');

                await delayExecution(1500);
            },
            
            async setDialogue(description, options = []) {
                roomDescriptionDiv.textContent = description;
                roomOptionsDiv.innerHTML = '';
                
                if (options.length > 0) {
                    options.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.className = 'px-4 py-2 text-white rounded-md transition duration-200';
                        btn.textContent = opt.text;
                        btn.onclick = () => {
                            roomOptionsDiv.querySelectorAll('button').forEach(b => b.disabled = true);
                            opt.action();
                        };
                        roomOptionsDiv.appendChild(btn);
                    });
                }
            },
            
            clearAnimations() {
                rollAnimationContainer.innerHTML = `<div class="visual-placeholder">Waiting for next action...</div>`;
            }
        };


        // ----------------- HANDLER MODULE: UNIQUE EFFECT LOGIC -----------------
        // ... (UniqueEffectHandlers remain the same as previous versions) ...
        const UniqueEffectHandlers = {
            getStrikerClashBonus(attacker) {
                const bonus = attacker.baseStats.consecutive_rounds || 0;
                if (bonus > 0) log(`${attacker.name} passive grants +${bonus} coin bonus to clash roll.`, 'log-special');
                return bonus;
            },
            onStrikerTurnEnd(character) {
                character.baseStats.consecutive_rounds = (character.baseStats.consecutive_rounds || 0) + 1;
                log(`${character.name} grows stronger! Coin Bonus: +${character.baseStats.consecutive_rounds}`, 'log-special');
            },
            applyNegateHit(attacker, ability, target) {
                attacker.baseStats.effects.push('NegateNextHit');
                log(`${attacker.name} phases and will negate the next incoming hit.`, 'log-special');
            },
            checkShutenMaruHeal(attacker, ability, target, diceRoll) {
                if (diceRoll === 8) {
                    const heal = attacker.baseStats.lastDamageTaken;
                    if (heal > 0) {
                        attacker.baseStats.currentHP = Math.min(attacker.baseStats.maxHP, attacker.baseStats.currentHP + heal);
                        log(`${attacker.name}'s Chrono-Fist triggers, healing ${heal} HP (Damage Taken: ${heal}).`, 'log-win');
                    }
                }
            },
            getBalterClashWinBonus(winner, loser) {
                const bonusDamage = rollDie(4);
                loser.baseStats.currentHP = Math.max(0, loser.baseStats.currentHP - bonusDamage);
                log(`${winner.name}'s One-Two lands a bonus d4 hit for ${bonusDamage} damage!`, 'log-damage');
            },
            executeGrapple(attacker, ability, target) {
                const rollA = rollDie(ability.dice);
                const rollT = rollDie(target.baseStats.grappleDie || 8);
                log(`${attacker.name} attempts Grapple (Roll: ${rollA} vs ${target.name} Defense Roll: ${rollT})`);

                if(rollA > rollT) { 
                    target.baseStats.effects.push('Grappled');
                    attacker.baseStats.isGrappling = true;
                    log(`${attacker.name} Grapples ${target.name}!`, 'log-special');
                } else {
                    log(`${attacker.name} fails Grapple on ${target.name}.`);
                }
            },
            removeGrappleStatus(attacker, ability, target) {
                target.baseStats.effects = target.baseStats.effects.filter(e => e !== 'Grappled');
                attacker.baseStats.isGrappling = false;
                log(`${target.name} is released from Grapple.`, 'log-special');
            },
            getZectusClashBonus(attacker, target) {
                const isFemale = target.baseStats.gender === attacker.uniquePassive.condition.target_gender;
                if (isFemale) {
                    log(`${attacker.name}'s passive grants +2 Coins vs female opponent!`, 'log-special');
                    return 2;
                }
                return 0;
            },
            resolveZectusDynamicAttack(attacker) {
                const state = attacker.baseStats.triSwordState;
                const subAbilities = {
                    'Scythe': { name: 'Tri-Sword: Scythe', type: 'ATTACK', damageType: 'Necrotic', baseAttack: 6, dice: 8, coins: 1 },
                    'Trident': { name: 'Tri-Sword: Trident', type: 'ATTACK', damageType: 'Physical', baseAttack: 7, dice: 10, coins: 1 },
                    'Hammer': { name: 'Tri-Sword: Hammer', type: 'ATTACK', damageType: 'Force', baseAttack: 8, dice: 12, coins: 1 },
                };

                const resolvedAbility = subAbilities[state];
                log(`${attacker.name} attacks with the ${state} Form. (Type: ${resolvedAbility.damageType})`, 'log-special');
                return resolvedAbility;
            },
            cycleTriSword(attacker, ability, target) {
                const weapons = ['Scythe', 'Trident', 'Hammer'];
                let idx = weapons.indexOf(attacker.baseStats.triSwordState);
                let next = (idx + 1) % weapons.length;
                attacker.baseStats.triSwordState = weapons[next];
                
                const damage = ability.baseAttack || 2;
                target.baseStats.currentHP = Math.max(0, target.baseStats.currentHP - damage);
                
                log(`${attacker.name} cycles to ${weapons[next]} and strikes ${target.name} for ${damage} damage.`, 'log-damage');
            },
            applyDefenseBonus(attacker, ability, target) {
                attacker.baseStats.effects.push('DefensePlusTwo');
                log(`${attacker.name} takes a Defensive Stance! (+2 Defense)`, 'log-special');
            }
        };

        // ----------------- ABILITY TYPE HANDLERS (Now ASYNC) -----------------
        const AbilityTypeHandlers = {
            ATTACK: async (attacker, ability, target, diceRoll) => {
                if (target.baseStats.effects.includes('NegateNextHit')) { 
                    log(`${target.name} Phases! Negating hit.`, 'log-win'); 
                    target.baseStats.effects = target.baseStats.effects.filter(e => e !== 'NegateNextHit'); 
                    return; 
                }

                await Visuals.showSlotMachineRoll(ability.dice || 1, diceRoll, `${attacker.name}'s Attack`);
                
                const coinBonus = rollCoins(ability.coins || 0);
                await Visuals.showCoinFlips(ability.coins || 0, coinBonus);
                
                let defense = target.baseStats.defense;
                if(target.baseStats.effects.includes('DefensePlusTwo')) defense += 2;
                
                let dmg = Math.max(0, (ability.baseAttack || 0) + coinBonus - defense);
                
                if (target.id === 'shutenmaru') target.baseStats.lastDamageTaken = dmg;

                target.baseStats.currentHP = Math.max(0, target.baseStats.currentHP - dmg);
                log(`${attacker.name} attacks with ${ability.name}. Hits for ${dmg} (${ability.damageType})`, 'log-damage');
                updateHealthUI();
                await delayExecution(500);

                Status.resolvePostAction(attacker, ability, target, diceRoll);
            },

            DEFENSE: async (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} takes a generic defensive action.`);
                }
                await delayExecution(1000);
            },

            SPECIAL: async (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} uses a generic special ability.`);
                }
                await delayExecution(1000);
            },
            
            SWITCH: async (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} attempts a switch but fails.`);
                }
                renderActions(); // Update buttons immediately for weapon change
                await delayExecution(1000);
            },

            DYNAMIC_ATTACK: async (attacker, ability, target) => {
                if (ability.resolver && UniqueEffectHandlers[ability.resolver]) {
                    const resolvedAbility = UniqueEffectHandlers[ability.resolver](attacker, ability);
                    
                    // Recursive call to ATTACK handler, which is now ASYNC
                    await AbilityTypeHandlers.ATTACK(attacker, resolvedAbility, target, rollDie(resolvedAbility.dice));
                }
            }
        };


        // ----------------- STATUS MECHANICS (Remains the same) -----------------
        const Status = {
            resolvePostAction: (attacker, ability, target, diceRoll = null) => {
                if (ability.statusApplied && !target.baseStats.effects.includes(ability.statusApplied)) {
                    target.baseStats.effects.push(ability.statusApplied);
                    log(`${target.name} is inflicted with ${ability.statusApplied}!`, 'log-special');
                }

                if (ability.postDamageHandler && UniqueEffectHandlers[ability.postDamageHandler]) {
                    UniqueEffectHandlers[ability.postDamageHandler](attacker, ability, target, diceRoll);
                }
                
                if (ability.postExecutionHandler && UniqueEffectHandlers[ability.postExecutionHandler]) {
                    UniqueEffectHandlers[ability.postExecutionHandler](attacker, ability, target);
                }
            },

            resolveTurnStart: (character) => {
                character.baseStats.effects = character.baseStats.effects.filter(e => 
                    e !== 'DefensePlusTwo' && e !== 'Stagger'
                );
            }
        };

        // ----------------- COMBAT ENGINE (ORCHESTRATOR - Now ASYNC) -----------------
        const Combat = {
            baseClashValue: 5,

            async executeAction(attacker, ability, target, diceRoll = null) {
                if (!ability || ability.type === 'NONE') return;

                if (ability.requiredTargetStatus && !target.baseStats.effects.includes(ability.requiredTargetStatus)) {
                    log(`${attacker.name}'s ${ability.name} failed: Target is not ${ability.requiredTargetStatus}.`);
                    return;
                }

                if (ability.type.includes('ATTACK') && !diceRoll) {
                    diceRoll = rollDie(ability.dice || 1);
                }

                if (AbilityTypeHandlers[ability.type]) {
                    // Await the handler for animation completion
                    await AbilityTypeHandlers[ability.type](attacker, ability, target, diceRoll);
                } else {
                    log(`ERROR: Unknown ability type: ${ability.type}`);
                    await delayExecution(500);
                }
            },

            async handleClash(playerAbility, enemyAbility) {
                const player = gameState.player;
                const enemy = gameState.enemy;

                // 1. Calculate Coins/Bonus
                let pClashBonus = 0;
                if (player.uniquePassive?.onClashRoll) {
                    const handlerName = player.uniquePassive.onClashRoll;
                    pClashBonus += UniqueEffectHandlers[handlerName](player, enemy);
                }
                let eClashBonus = 0;
                if (enemy.uniquePassive?.onClashRoll) {
                    const handlerName = enemy.uniquePassive.onClashRoll;
                    eClashBonus += UniqueEffectHandlers[handlerName](enemy, player);
                }
                
                // 2. Perform Rolls
                const pDiceRoll = rollDie(playerAbility.dice || 1);
                const eDiceRoll = rollDie(enemyAbility.dice || 1);

                const pCoins = (playerAbility.coins || 0) + pClashBonus;
                const eCoins = (enemyAbility.coins || 0) + eClashBonus;

                const pCoinBonus = rollCoins(pCoins);
                const eCoinBonus = rollCoins(eCoins);

                const playerRoll = this.baseClashValue + pDiceRoll + pCoinBonus;
                const enemyRoll = this.baseClashValue + eDiceRoll + eCoinBonus;

                log(`Clash Rolls: P(${playerRoll}, D:${pDiceRoll}, C:${pCoinBonus}) vs E(${enemyRoll}, D:${eDiceRoll}, C:${eCoinBonus})`);

                // 3. Visualize Clash
                await Visuals.showClashAnimation(playerRoll, enemyRoll);
                
                if (playerRoll >= enemyRoll) {
                    log(`${player.name} wins the clash!`, 'log-win');
                    await this.executeAction(player, playerAbility, enemy, pDiceRoll); // Await action
                    
                    if (player.uniquePassive?.onClashWin) {
                        UniqueEffectHandlers[player.uniquePassive.onClashWin](player, enemy);
                    }
                } else {
                    log(`${enemy.name} wins the clash!`, 'log-loss');
                    await this.executeAction(enemy, enemyAbility, player, eDiceRoll); // Await action
                    
                    if (enemy.uniquePassive?.onClashWin) {
                        UniqueEffectHandlers[enemy.uniquePassive.onClashWin](enemy, player);
                    }
                }
            }
        };

        // ----------------- GAME FLOW (Now ASYNC) -----------------
        async function executeAbility(ability) {
            if (gameState.isResolving) return;
            gameState.isResolving = true;
            gameState.playerAction = ability;
            
            // Disable buttons immediately
            renderActions(); 
            
            await selectEnemyAction();
            await resolveTurn();
        }

        async function resolveTurn() {
            const p = gameState.playerAction;
            const e = gameState.enemyAction;
            const player = gameState.player;
            const enemy = gameState.enemy;
            
            Visuals.clearAnimations();
            log(`--- Turn ${gameState.turn} ---`, 'log-special');

            const pIsAttack = p.type === 'ATTACK' || p.type === 'DYNAMIC_ATTACK';
            const eIsAttack = e.type === 'ATTACK' || e.type === 'DYNAMIC_ATTACK';

            if (pIsAttack && eIsAttack) {
                await Combat.handleClash(p, e); // Await clash resolution
            }
            else {
                // Determine turn order based on Speed
                let [first, second] = (player.baseStats.speed >= enemy.baseStats.speed)
                    ? [player, enemy]
                    : [enemy, player];

                let [firstAbility, secondAbility] = (first === player)
                    ? [p, e]
                    : [e, p];

                // Execute First action (Await the action for visualization)
                await Combat.executeAction(first, firstAbility, second);

                // Execute Second action if alive and not staggered
                const secondIsStaggered = second.baseStats.effects.includes('Stagger');
                if (second.baseStats.currentHP > 0 && secondAbility.type !== 'NONE' && !secondIsStaggered) {
                    await Combat.executeAction(second, secondAbility, first); // Await action
                } else if (secondIsStaggered) {
                    log(`${second.name} was Staggered and could not act!`);
                }
            }

            // Final state check and cleanup
            await endTurnCleanup();
        }

        async function endTurnCleanup() {
            // Give a moment for the last action log/HP update to sink in
            await delayExecution(500); 

            Status.resolveTurnStart(gameState.player);
            Status.resolveTurnStart(gameState.enemy);
            
            if (gameState.player.uniquePassive?.onTurnEnd) {
                const handlerName = gameState.player.uniquePassive.onTurnEnd;
                UniqueEffectHandlers[handlerName](gameState.player);
            }

            if (gameState.player.baseStats.currentHP <= 0) {
                log(`${gameState.player.name} has been defeated! Game Over.`, 'log-loss');
                dialogueText.textContent = 'GAME OVER';
                Visuals.setDialogue(`The mighty ${gameState.enemy.name} has bested you. The quest ends here.`, [
                    { text: 'Start Over', action: () => setView('select') }
                ]);
            } else if (gameState.enemy.baseStats.currentHP <= 0) {
                log(`${gameState.enemy.name} has been defeated! You Win!`, 'log-win');
                dialogueText.textContent = 'VICTORY!';
                Visuals.setDialogue(`You defeated the ${gameState.enemy.name}! What do you do next?`, [
                    { text: 'Loot Corpse (Not implemented)', action: () => log('You search the goblin. Nothing useful found.') },
                    { text: 'Continue to Next Room', action: () => setView('select') } // Placeholder for next room
                ]);
            } else {
                gameState.turn++;
                gameState.playerAction = null;
                gameState.enemyAction = null;
                gameState.isResolving = false;
                
                updateHealthUI();
                renderActions();
                dialogueText.textContent = 'Choose your action:';
                turnCounter.textContent = gameState.turn;
                
                Visuals.setDialogue(`The battle continues. Turn ${gameState.turn}.`);
            }
        }

        async function selectEnemyAction() {
            const enemy = gameState.enemy;
            
            if (enemy.baseStats.currentHP <= 0) {
                gameState.enemyAction = { name: 'Dead', type: 'NONE' };
                return;
            }

            if (enemy.baseStats.effects.includes('Stagger')) {
                gameState.enemyAction = { name: 'Staggered', type: 'NONE' };
                log(`${enemy.name} is Staggered and skips its turn.`);
                return;
            }

            // Simple Goblin AI: 50/50 attack/defense
            const attack = enemy.abilities.find(a => a.type === 'ATTACK');
            const defense = enemy.abilities.find(a => a.type === 'DEFENSE');

            if (Math.random() < 0.5 && defense) {
                gameState.enemyAction = defense;
            } else if (attack) {
                gameState.enemyAction = attack;
            } else {
                gameState.enemyAction = { name: 'Wait', type: 'NONE' };
            }

            log(`${enemy.name} chooses ${gameState.enemyAction.name}`);
        }

        // ----------------- UI -----------------

        function updateHealthUI() {
            const update = (entity, ui) => {
                const perc = Math.max(0, (entity.baseStats.currentHP / entity.baseStats.maxHP) * 100);
                ui.hpBar.style.width = perc + '%';
                ui.hpText.textContent = `${entity.baseStats.currentHP}/${entity.baseStats.maxHP}`;
                
                const effectsText = entity.baseStats.effects.length ? ` (${entity.baseStats.effects.join(', ')})` : '';
                ui.statusText.textContent = `Status: ${entity.baseStats.status || 'Active'}${effectsText}`;
            };
            update(gameState.player, playerStatus);
            update(gameState.enemy, enemyStatus);
        }

        function renderActions() {
            actionButtonsDiv.innerHTML = '';
            
            const isEnemyGrappled = gameState.enemy?.baseStats?.effects?.includes('Grappled');
            
            const visibleAbilities = gameState.player?.abilities?.filter(a => !a.isHidden) || [];

            visibleAbilities.forEach(ability => {
                const btn = document.createElement('button');
                btn.classList.add('combat-btn');
                let displayName = ability.name;

                if (ability.name === 'Piledriver') {
                    btn.disabled = !isEnemyGrappled || gameState.isResolving;
                    if (isEnemyGrappled) {
                        btn.classList.add('combo-ready');
                    } else {
                        btn.classList.remove('combo-ready');
                    }
                }
                
                if (gameState.player.id === 'zectus' && ability.isZectusMainAttack) {
                    const currentWeapon = gameState.player.baseStats.triSwordState;
                    displayName = `Tri-Sword: ${currentWeapon}`;
                    btn.classList.add('active-weapon-btn'); 
                }

                if (gameState.isResolving) {
                    btn.disabled = true;
                }

                btn.textContent = displayName;
                btn.onclick = () => executeAbility(ability);
                actionButtonsDiv.appendChild(btn);
            });
        }


        function renderCharacterSelect() {
            $('char-select-cards').innerHTML = '';
            Characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'char-card card cursor-pointer';
                card.innerHTML = `
                    <h3 class="text-2xl">${char.name}</h3>
                    <p class="text-sm">${char.description}</p>
                    <div class="text-xs mt-2">
                        <p>HP: ${char.baseStats.maxHP} | Def: ${char.baseStats.defense} | Speed: ${char.baseStats.speed}</p>
                        <p class="font-semibold mt-1">Passive: ${char.uniquePassive.name}</p>
                        <p class="text-xs italic">${char.uniquePassive.effect}</p>
                    </div>
                `;
                card.onclick = () => startCombat(char.id);
                $('char-select-cards').appendChild(card);
            });
        }

        function startCombat(playerId) {
            const playerTemplate = Characters.find(c => c.id === playerId);
            gameState.player = JSON.parse(JSON.stringify(playerTemplate));
            gameState.enemy = JSON.parse(JSON.stringify(ENEMY_GOBLIN));
            
            gameState.player.baseStats.currentHP = gameState.player.baseStats.maxHP;
            gameState.enemy.baseStats.currentHP = gameState.enemy.baseStats.maxHP;
            
            gameState.turn = 1;
            gameState.isResolving = false;
            combatLog.innerHTML = '';
            turnCounter.textContent = gameState.turn;
            
            log(`${gameState.player.name} (Speed: ${gameState.player.baseStats.speed}) enters the Arena!`);
            log(`Opponent: ${gameState.enemy.name} (Speed: ${gameState.enemy.baseStats.speed}).`, 'log-special');
            
            playerStatus.name.textContent = gameState.player.name;
            enemyStatus.name.textContent = gameState.enemy.name;

            setView('combat');
            Visuals.clearAnimations();
            Visuals.setDialogue(`You encounter a hostile ${gameState.enemy.name}! Prepare for Turn 1.`);
            
            updateHealthUI();
            renderActions();
        }

        function setView(view) {
            menuScreen.classList.add('hidden');
            charSelectScreen.classList.add('hidden');
            gameContainer.classList.add('hidden');

            if (view === 'menu') menuScreen.classList.remove('hidden');
            if (view === 'select') charSelectScreen.classList.remove('hidden');
            if (view === 'combat') gameContainer.classList.remove('hidden');
        }

        // ----------------- THEME / SETTINGS -----------------
        function applyTheme(theme) {
            body.className = ''; 
            body.classList.add(`${theme}-theme`);
            localStorage.setItem('gameTheme', theme);
            gameState.currentTheme = theme;
        }

        function toggleSettingsPanel() { settingsPanel.classList.toggle('open'); }


        // ----------------- INITIALIZATION -----------------

        function init() {
            applyTheme(localStorage.getItem('gameTheme')||'default'); 
            setView('menu'); 
            renderCharacterSelect();

            newGameBtn.addEventListener('click', () => setView('select'));

            openSettingsBtn.addEventListener('click', toggleSettingsPanel);
            closeSettingsBtn.addEventListener('click', toggleSettingsPanel);
            
            themeOptionBtns.forEach(btn => {
                btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
            });
            
            // Initial Dialogue for Menu
            Visuals.setDialogue('Welcome to the Chronicles of Heroes. Choose New Game to begin your adventure!');
        }

        window.onload = init;
    </script>
</body>
</html>
