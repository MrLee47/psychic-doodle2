<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronicles of Heroes: Erebos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    
    <!-- CONSOLIDATED STYLES FROM style.css -->
    <style>
        /* -------------------------------------------------------------------------- */
        /* THEME DEFINITIONS */
        /* -------------------------------------------------------------------------- */

        /* Default (Cream/Fantasy) Theme */
        .default-theme {
            --bg-color: #f7f3e8; /* Cream background */
            --primary-color: #4a2d1e; /* Dark earth tone */
            --text-color: #333;
            --border-color: #8c735d;
            --button-bg: #8c735d;
            --button-hover-bg: #b1937e;
            --status-bar-bg: #e2eaf0;
            --hp-color: #d13d3d;
            --hp-bg: #f5caca;
            --mp-color: #3b82f6; /* Blue */
            --log-special: #047857; /* Darker Green highlight */
            --log-win: #059669; /* Darker Green */
            --log-loss: #b91c1c; /* Dark Red */
            --log-damage: #b45309; /* Dark Orange for damage */
            font-family: 'Inter', sans-serif;
        }

        /* Retro (Green/Terminal) Theme */
        .retro-theme {
            --bg-color: #1a1a1a;
            --primary-color: #00ff41; /* Neon green */
            --text-color: #00ff41;
            --border-color: #008020;
            --button-bg: #006400;
            --button-hover-bg: #00b300;
            --status-bar-bg: #0a0a0a;
            --hp-color: #ff0000;
            --hp-bg: #330000;
            --mp-color: #00ffff; /* Cyan */
            --log-special: #ffff00; /* Yellow */
            --log-win: #00ff41;
            --log-loss: #ff0000;
            --log-damage: #ff8c00; /* Dark orange */
            font-family: 'Monospace', monospace;
        }

        /* General Styles */
        * {
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow-x: hidden;
            font-size: 16px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .hidden { display: none !important; }

        /* Card and Container Styles */
        .container {
            max-width: 800px;
            width: 95%;
            padding: 20px;
            background-color: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .card {
            background-color: var(--status-bar-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Text and Typography */
        h1, h2 {
            color: var(--primary-color);
            font-weight: 900;
            text-align: center;
            margin-bottom: 15px;
        }
        h3 {
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Buttons */
        button {
            background-color: var(--button-bg);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
        }
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        button:disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }
        .combat-btn {
            min-width: 150px;
        }

        .combo-ready {
            border: 2px solid var(--hp-color) !important;
            background-color: var(--hp-color);
        }

        .active-weapon-btn {
            border: 2px solid var(--mp-color);
            background-color: var(--mp-color);
        }

        /* Status Bars */
        .hp-bar-container {
            height: 25px;
            background-color: var(--hp-bg);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
            border: 1px solid var(--border-color);
        }

        .hp-bar-fill {
            height: 100%;
            background-color: var(--hp-color);
            transition: width 0.3s ease-out;
        }

        .hp-text {
            font-size: 0.9em;
            text-align: center;
            font-weight: 700;
            color: var(--primary-color);
        }

        .status-text {
            font-size: 0.8em;
            text-align: center;
            color: var(--log-special);
        }

        /* Combat Log */
        #combat-log {
            height: 250px;
            overflow-y: scroll;
            padding: 10px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
        }

        .log-entry {
            font-size: 0.9em;
            padding: 2px 0;
            border-bottom: 1px dotted rgba(0, 0, 0, 0.1);
            color: var(--text-color);
        }

        .log-win { color: var(--log-win); font-weight: 700; }
        .log-loss { color: var(--log-loss); font-weight: 700; }
        .log-damage { color: var(--log-damage); font-weight: 700; }
        .log-special { color: var(--log-special); font-style: italic; }

        /* Character Select */
        .char-card {
            text-align: center;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid transparent;
        }

        .char-card:hover {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border-color: var(--accent-color);
        }

        .char-card.selected {
            border: 3px solid var(--hp-color);
            transform: scale(1.05);
        }

        /* SETTINGS PANEL */
        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100%;
            background-color: var(--status-bar-bg);
            border-left: 2px solid var(--border-color);
            padding: 20px;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }

        .settings-panel.open {
            transform: translateX(0);
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-color);
            padding: 0;
            cursor: pointer;
            box-shadow: none;
        }

        .theme-selector h3 {
            margin-top: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        .theme-selector button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px;
        }

    </style>
</head>
<body class="default-theme flex-col">

    <!-- Menu Screen -->
    <div id="menu-screen" class="min-h-screen flex flex-col items-center justify-center p-4 w-full">
        <div class="container text-center">
            <h1 class="text-5xl font-extrabold mb-8">Chronicles of Heroes</h1>
            <div class="space-y-4">
                <button id="new-game-btn" class="w-64">New Game</button>
                <button id="load-game-btn" class="w-64" disabled>Load Game</button>
                <button id="open-settings-menu-btn" class="w-64">Settings</button>
            </div>
        </div>
    </div>

    <!-- Character Select Screen -->
    <div id="character-select-screen" class="hidden min-h-screen flex flex-col items-center p-4 w-full">
        <div class="container">
            <h2 class="text-3xl mt-4 mb-6">Select Your Hero</h2>
            <div id="char-select-cards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 w-full">
                <!-- Character Cards Rendered Here -->
            </div>
        </div>
    </div>

    <!-- Combat Arena -->
    <div id="game-container" class="hidden container">
        <h2 class="text-3xl mb-6">Combat Arena</h2>
        
        <!-- Status Bars -->
        <div class="flex justify-between space-x-4 mb-6">
            <!-- Player Status -->
            <div class="w-1/2 card">
                <h3 id="player-name" class="text-xl mb-2">Player</h3>
                <div class="hp-bar-container">
                    <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%;"></div>
                </div>
                <p id="player-hp-text" class="hp-text">100/100</p>
                <p id="player-status-text" class="status-text italic"></p>
            </div>

            <!-- Enemy Status -->
            <div class="w-1/2 card">
                <h3 id="enemy-name" class="text-xl mb-2 text-right">Enemy</h3>
                <div class="hp-bar-container">
                    <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%;"></div>
                </div>
                <p id="enemy-hp-text" class="hp-text">80/80</p>
                <p id="enemy-status-text" class="status-text italic"></p>
            </div>
        </div>

        <!-- Combat Log -->
        <div class="card mb-6">
            <h4 class="text-lg font-semibold mb-2">Combat Log</h4>
            <div id="combat-log">
                <!-- Log entries here -->
            </div>
        </div>

        <!-- Action Panel -->
        <div class="card">
            <h4 id="dialogue-text" class="text-lg font-semibold mb-4 text-center">Choose your action:</h4>
            <div id="action-buttons" class="flex flex-wrap gap-3 justify-center">
                <!-- Buttons rendered here -->
            </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-panel" class="settings-panel">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-2xl font-bold">Settings</h3>
            <button id="close-settings-btn" class="close-btn">&times;</button>
        </div>
        <div class="theme-selector">
            <h4 class="text-lg font-semibold mb-3">Theme Selection</h4>
            <button class="theme-option-btn" data-theme="default">Default (Cream)</button>
            <button class="theme-option-btn" data-theme="retro">Retro (Green Terminal)</button>
        </div>
    </div>

    <script>
        /* -------------------------------------------------------\
           Chronicles of Heroes: Consolidated & Modular Core
           ------------------------------------------------------- */

        // ----------------- GLOBAL STATE -----------------
        const gameState = {
            isGameStarted: false,
            currentView: 'menu',
            player: null,
            enemy: null,
            currentTheme: 'default',
            turn: 1,
            playerAction: null,
            enemyAction: null,
        };

        // ----------------- DOM REFS -----------------
        const $ = (id) => document.getElementById(id);
        const body = document.body;
        const menuScreen = $('menu-screen');
        const gameContainer = $('game-container');
        const charSelectScreen = $('character-select-screen');

        const newGameBtn = $('new-game-btn');
        const loadGameBtn = $('load-game-btn');
        const openSettingsBtn = $('open-settings-menu-btn');
        const settingsPanel = $('settings-panel');
        const closeSettingsBtn = $('close-settings-btn');
        const themeOptionBtns = document.querySelectorAll('.theme-option-btn');

        const dialogueText = $('dialogue-text');
        const actionButtonsDiv = $('action-buttons');
        const combatLog = $('combat-log');

        const playerStatus = {
            name: $('player-name'),
            hpBar: $('player-hp-bar'),
            hpText: $('player-hp-text'),
            statusText: $('player-status-text'),
        };
        const enemyStatus = {
            name: $('enemy-name'),
            hpBar: $('enemy-hp-bar'),
            hpText: $('enemy-hp-text'),
            statusText: $('enemy-status-text'),
        };

        // ----------------- UTILITIES -----------------
        const rollDie = (max) => Math.floor(Math.random() * max) + 1;
        const rollCoins = (count) => Array.from({ length: count }, () => Math.random() < 0.5 ? 1 : 0)
                                        .reduce((a,b)=>a+b, 0);

        function log(message, className='log-entry') {
            const p = document.createElement('p');
            p.className = `log-entry ${className}`;
            p.textContent = `[T${gameState.turn}] ${message}`;
            combatLog.prepend(p);
            while(combatLog.children.length > 50) combatLog.removeChild(combatLog.lastChild);
        }

        // ----------------- CONSOLIDATED CHARACTER DATA (from characters.js) -----------------

        const Characters = [
            // --- 1. Striker (Slow Start: Coin Scaler) ---
            {
                id: 'striker',
                name: 'Striker',
                description: 'A damage specialist who scales in power the longer a fight lasts.',
                baseStats: {
                    maxHP: 110,
                    defense: 2,
                    level: 1,
                    // Unique state tracking:
                    consecutive_rounds: 0, 
                    effects: [],
                },
                uniquePassive: { 
                    name: 'Slow Start', 
                    effect: 'Each consecutive combat round, gains +1 Coin to all attacks.',
                    type: 'CoinScaler', // Used to reference handler logic
                    onClashRoll: 'getStrikerClashBonus', 
                    onTurnEnd: 'onStrikerTurnEnd' 
                },
                abilities: [
                    {
                        name: 'Dragon Strike',
                        type: 'ATTACK',
                        damageType: 'Force',
                        baseAttack: 4, 
                        dice: 4, 
                        coins: 2, 
                    },
                    {
                        name: 'Heavy Blow',
                        type: 'ATTACK',
                        damageType: 'Physical',
                        baseAttack: 10,
                        dice: 12,
                        coins: 0,
                        statusApplied: 'Stagger',
                    }
                ]
            },
            // --- 2. Balter (Wrestling Powerhouse) ---
            {
                id: 'balter',
                name: 'Balter',
                description: 'A wrestling powerhouse who locks down targets for massive damage.',
                baseStats: {
                    maxHP: 130,
                    defense: 3,
                    level: 1,
                    grappleDie: 8,
                    isGrappling: false,
                    effects: [],
                },
                uniquePassive: { 
                    name: 'The Old One, Two', 
                    effect: 'Roll an extra d4 damage on any successful clash.',
                    type: 'ClashWinBonus',
                    onClashWin: 'getBalterClashWinBonus'
                },
                abilities: [
                    {
                        name: 'Haymaker',
                        type: 'ATTACK',
                        damageType: 'Blunt',
                        baseAttack: 7, 
                        dice: 10,
                        coins: 1,
                    },
                    {
                        name: 'Grapple',
                        type: 'SPECIAL',
                        effect: 'Roll d10 vs target\'s d8. On success, applies Grappled status.',
                        effectHandler: 'executeGrapple',
                        dice: 10, 
                        coins: 0,
                        statusApplied: 'Grappled', // Status applied only on success via handler
                    },
                    {
                        name: 'Piledriver',
                        type: 'ATTACK',
                        damageType: 'Physical',
                        baseAttack: 12,
                        dice: 12,
                        coins: 0,
                        requiredTargetStatus: 'Grappled',
                        postExecutionHandler: 'removeGrappleStatus', // New handler to remove status
                    }
                ]
            },
            // --- 3. Shuten-Maru (Chrono-Fist) ---
            {
                id: 'shutenmaru',
                name: 'Shuten-Maru',
                description: 'Undying psycho demon who utilizes outbursts of divine power',
                baseStats: {
                    maxHP: 100,
                    defense: 1,
                    level: 1,
                    lastDamageTaken: 0, // Unique state tracking
                    effects: [],
                },
                uniquePassive: { 
                    name: 'Chrono-Fist', 
                    effect: 'If an attack die roll is 8, heal for the damage taken in the previous turn.',
                    type: 'RollTrigger',
                },
                abilities: [
                    {
                        name: 'Ghost Fist',
                        type: 'ATTACK',
                        damageType: 'Psychic',
                        baseAttack: 6, 
                        dice: 8,
                        coins: 1,
                        // Post-damage handler to check for heal trigger
                        postDamageHandler: 'checkShutenMaruHeal', 
                    },
                    {
                        name: 'Phase',
                        type: 'DEFENSE',
                        effect: 'Negates the next incoming hit.',
                        effectHandler: 'applyNegateHit', // References handler
                        baseAttack: 0, 
                        dice: 0,
                        coins: 0,
                    }
                ]
            },
            // --- 4. Zectus Maximus (Tri-Sword) ---
            {
                id: 'zectus',
                name: 'Zectus Maximus',
                description: 'A versatile warrior whose damage type changes with his weapon form.',
                baseStats: {
                    maxHP: 105,
                    defense: 2,
                    level: 1,
                    effects: [],
                    gender: 'Male',
                    triSwordState: 'Scythe', // Tracks current weapon form
                },
                uniquePassive: { 
                    name: 'Homogenous', 
                    effect: 'Adds +2 Coins to Clashes against female opponents.',
                    type: 'ConditionalCoin',
                    condition: { target_gender: 'Female' },
                    onClashRoll: 'getZectusClashBonus'
                },
                abilities: [
                    {
                        name: 'Cycle',
                        type: 'SWITCH',
                        effect: 'Cycles Tri-Sword: Scythe -> Trident -> Hammer. Deals 2 damage on activation.',
                        effectHandler: 'cycleTriSword', // References handler
                        baseAttack: 2, // Activation damage
                        dice: 0,
                        coins: 0,
                    },
                    // Dynamic attack abilities are now templates only
                    {
                        name: 'Tri-Sword: Main Attack',
                        id: 'tri_sword_main',
                        type: 'DYNAMIC_ATTACK',
                        resolver: 'resolveZectusDynamicAttack', // References resolver handler
                        dice: 8, // Base dice for clash
                        coins: 1, // Base coins for clash
                        isZectusMainAttack: true, // Marker for UI
                    },
                ]
            },
        ];

        // Enemy Template
        const ENEMY_GOBLIN = {
            id:'goblin',
            name:'Gravel-Claw Goblin',
            description: 'A basic enemy with a simple attack and defense.',
            baseStats:{ 
                maxHP: 80, 
                currentHP: 80, 
                defense: 2, 
                speed: 2, 
                status:'Alive', 
                effects: [], 
                grappleDie: 6, 
                gender:'Female' // For Zectus's passive test
            },
            abilities:[
                { name:'Gnaw Attack', type:'ATTACK', baseAttack:5, dice:6, coins:2, damageType:'Physical' },
                { name:'Defensive Crouch', type:'DEFENSE', effectHandler:'applyDefenseBonus', baseAttack:0, dice:0, coins:0 }
            ]
        };

        function getCharacterTemplate(id) {
            return Characters.find(c => c.id === id);
        }

        // ----------------- HANDLER MODULE: UNIQUE EFFECT LOGIC -----------------
        // This is the core of the modular pattern, keeping all character-specific
        // code separate from the main Combat engine.

        const UniqueEffectHandlers = {

            // --- STRIKER Handlers ---
            getStrikerClashBonus(attacker) {
                const bonus = attacker.baseStats.consecutive_rounds || 0;
                if (bonus > 0) log(`${attacker.name} passive grants +${bonus} coin bonus to clash roll.`, 'log-special');
                return bonus;
            },
            onStrikerTurnEnd(character) {
                character.baseStats.consecutive_rounds = (character.baseStats.consecutive_rounds || 0) + 1;
                log(`${character.name} grows stronger! Coin Bonus: +${character.baseStats.consecutive_rounds}`, 'log-special');
            },

            // --- SHUTEN-MARU Handlers ---
            applyNegateHit(attacker, ability, target) {
                attacker.baseStats.effects.push('NegateNextHit');
                log(`${attacker.name} phases and will negate the next incoming hit.`, 'log-special');
            },
            // This runs after Shuten-Maru lands a hit
            checkShutenMaruHeal(attacker, ability, target, diceRoll) {
                // If the d8 roll was an 8 (Chrono-Fist trigger)
                if (diceRoll === 8) {
                    const heal = attacker.baseStats.lastDamageTaken;
                    if (heal > 0) {
                        attacker.baseStats.currentHP = Math.min(attacker.baseStats.maxHP, attacker.baseStats.currentHP + heal);
                        log(`${attacker.name}'s Chrono-Fist triggers, healing ${heal} HP (Damage Taken: ${heal}).`, 'log-win');
                    }
                }
            },
            
            // --- BALTER Handlers ---
            getBalterClashWinBonus(winner, loser) {
                const bonusDamage = rollDie(4);
                loser.baseStats.currentHP = Math.max(0, loser.baseStats.currentHP - bonusDamage);
                log(`${winner.name}'s One-Two lands a bonus d4 hit for ${bonusDamage} damage!`, 'log-damage');
            },
            executeGrapple(attacker, ability, target) {
                const rollA = rollDie(ability.dice);
                const rollT = rollDie(target.baseStats.grappleDie || 8);
                log(`${attacker.name} attempts Grapple (Roll: ${rollA} vs ${target.name} Defense Roll: ${rollT})`);

                if(rollA > rollT) { 
                    target.baseStats.effects.push('Grappled');
                    attacker.baseStats.isGrappling = true;
                    log(`${attacker.name} Grapples ${target.name}!`, 'log-special');
                } else {
                    log(`${attacker.name} fails Grapple on ${target.name}.`);
                }
            },
            removeGrappleStatus(attacker, ability, target) {
                target.baseStats.effects = target.baseStats.effects.filter(e => e !== 'Grappled');
                attacker.baseStats.isGrappling = false;
                log(`${target.name} is released from Grapple.`, 'log-special');
            },
            
            // --- ZECTUS Handlers ---
            getZectusClashBonus(attacker, target) {
                const isFemale = target.baseStats.gender === attacker.uniquePassive.condition.target_gender;
                if (isFemale) {
                    log(`${attacker.name}'s passive grants +2 Coins vs female opponent!`, 'log-special');
                    return 2;
                }
                return 0;
            },
            // Resolver to find the current active ability template
            resolveZectusDynamicAttack(attacker) {
                const state = attacker.baseStats.triSwordState;
                
                // Manually define the sub-abilities since they were removed from the array
                const subAbilities = {
                    'Scythe': { name: 'Tri-Sword: Scythe', type: 'ATTACK', damageType: 'Necrotic', baseAttack: 6, dice: 8, coins: 1 },
                    'Trident': { name: 'Tri-Sword: Trident', type: 'ATTACK', damageType: 'Physical', baseAttack: 7, dice: 10, coins: 1 },
                    'Hammer': { name: 'Tri-Sword: Hammer', type: 'ATTACK', damageType: 'Force', baseAttack: 8, dice: 12, coins: 1 },
                };

                const resolvedAbility = subAbilities[state];
                log(`${attacker.name} attacks with the ${state} Form. (Type: ${resolvedAbility.damageType})`, 'log-special');
                return resolvedAbility;
            },
            cycleTriSword(attacker, ability, target) {
                const weapons = ['Scythe', 'Trident', 'Hammer'];
                let idx = weapons.indexOf(attacker.baseStats.triSwordState);
                let next = (idx + 1) % weapons.length;
                attacker.baseStats.triSwordState = weapons[next];
                
                // Apply switch damage (as per user's ability description)
                const damage = ability.baseAttack || 2;
                target.baseStats.currentHP = Math.max(0, target.baseStats.currentHP - damage);
                
                log(`${attacker.name} cycles to ${weapons[next]} and strikes ${target.name} for ${damage} damage.`, 'log-damage');
            },

            // --- GENERIC Handlers ---
            applyDefenseBonus(attacker, ability, target) {
                // Goblin's Defensive Crouch
                attacker.baseStats.effects.push('DefensePlusTwo');
                log(`${attacker.name} takes a Defensive Stance! (+2 Defense)`, 'log-special');
            }
        };

        // ----------------- ABILITY TYPE HANDLERS -----------------
        const AbilityTypeHandlers = {
            ATTACK: (attacker, ability, target, diceRoll) => {
                // Pre-Damage Status Check (e.g., NegateNextHit)
                if (target.baseStats.effects.includes('NegateNextHit')) { 
                    log(`${target.name} Phases! Negating hit.`, 'log-win'); 
                    target.baseStats.effects = target.baseStats.effects.filter(e => e !== 'NegateNextHit'); 
                    return; 
                }

                // 1. Calculate Coin Bonus
                const coinBonus = rollCoins(ability.coins || 0);

                // 2. Calculate Damage
                let dmg = Math.max(0, (ability.baseAttack || 0) + coinBonus - target.baseStats.defense);
                
                // Save damage taken for Shuten-Maru
                if (target.id === 'shutenmaru') target.baseStats.lastDamageTaken = dmg;

                // 3. Apply Damage
                target.baseStats.currentHP = Math.max(0, target.baseStats.currentHP - dmg);
                log(`${attacker.name} hits for ${dmg} (${ability.damageType})`, 'log-damage');

                // 4. Post-Damage/Status Application
                Status.resolvePostAction(attacker, ability, target, diceRoll);
            },

            DEFENSE: (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} takes a generic defensive action.`);
                }
            },

            SPECIAL: (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} uses a generic special ability, but nothing happens!`);
                }
            },
            
            SWITCH: (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} attempts a switch but fails.`);
                }
            },

            DYNAMIC_ATTACK: (attacker, ability, target) => {
                // DYNAMIC_ATTACK is a resolver that calls an ATTACK handler
                if (ability.resolver && UniqueEffectHandlers[ability.resolver]) {
                    // This resolves the DYNAMIC ability to an actual ATTACK ability template
                    const resolvedAbility = UniqueEffectHandlers[ability.resolver](attacker, ability);
                    
                    // Re-execute as a standard ATTACK
                    AbilityTypeHandlers.ATTACK(attacker, resolvedAbility, target, rollDie(resolvedAbility.dice));
                }
            }
        };


        // ----------------- STATUS MECHANICS -----------------
        const Status = {
            resolvePostAction: (attacker, ability, target, diceRoll = null) => {
                // 1. Apply Status effect defined in the ability (e.g., Stagger)
                if (ability.statusApplied && !target.baseStats.effects.includes(ability.statusApplied)) {
                    target.baseStats.effects.push(ability.statusApplied);
                    log(`${target.name} is inflicted with ${ability.statusApplied}!`, 'log-special');
                }

                // 2. Run post-damage/post-action handler (e.g., Shuten-Maru heal check)
                if (ability.postDamageHandler && UniqueEffectHandlers[ability.postDamageHandler]) {
                    UniqueEffectHandlers[ability.postDamageHandler](attacker, ability, target, diceRoll);
                }
                
                // 3. Run post-execution handler (e.g., Balter's Piledriver status cleanup)
                if (ability.postExecutionHandler && UniqueEffectHandlers[ability.postExecutionHandler]) {
                    UniqueEffectHandlers[ability.postExecutionHandler](attacker, ability, target);
                }
            },

            // Runs at the start of the turn for cleanup
            resolveTurnStart: (character) => {
                // Remove temporary status effects (they should be cleared at turn start)
                character.baseStats.effects = character.baseStats.effects.filter(e => 
                    e !== 'DefensePlusTwo' && e !== 'Stagger'
                );
            }
        };

        // ----------------- COMBAT ENGINE (ORCHESTRATOR) -----------------
        const Combat = {
            baseClashValue: 5,

            executeAction(attacker, ability, target, diceRoll = null) {
                if (!ability || ability.type === 'NONE') return;

                // Pre-Execution Check: Does this ability require a specific status on the target?
                if (ability.requiredTargetStatus && !target.baseStats.effects.includes(ability.requiredTargetStatus)) {
                    log(`${attacker.name}'s ${ability.name} failed: Target is not ${ability.requiredTargetStatus}.`);
                    return;
                }

                // Standard ATTACKs need a dice roll for the handler (Shuten-Maru)
                if (ability.type === 'ATTACK' && !diceRoll) {
                    diceRoll = rollDie(ability.dice || 1);
                }

                // Delegate execution to the appropriate Ability Type Handler
                if (AbilityTypeHandlers[ability.type]) {
                    AbilityTypeHandlers[ability.type](attacker, ability, target, diceRoll);
                } else {
                    log(`ERROR: Unknown ability type: ${ability.type}`);
                }
            },

            handleClash(playerAbility, enemyAbility) {
                const player = gameState.player;
                const enemy = gameState.enemy;

                // 1. Calculate Player Coins/Bonus from Passives
                let pClashBonus = 0;
                if (player.uniquePassive?.onClashRoll) {
                    const handlerName = player.uniquePassive.onClashRoll;
                    pClashBonus += UniqueEffectHandlers[handlerName](player, enemy); // Pass both for Zectus
                }
                
                // 2. Perform Rolls
                const pDiceRoll = rollDie(playerAbility.dice || 1);
                const eDiceRoll = rollDie(enemyAbility.dice || 1);

                const pCoins = (playerAbility.coins || 0) + pClashBonus;
                const eCoins = enemyAbility.coins || 0;

                const pCoinBonus = rollCoins(pCoins);
                const eCoinBonus = rollCoins(eCoins);

                const playerRoll = this.baseClashValue + pDiceRoll + pCoinBonus;
                const enemyRoll = this.baseClashValue + eDiceRoll + eCoinBonus;

                log(`Clash Rolls: P(${playerRoll}, D:${pDiceRoll}, C:${pCoinBonus}) vs E(${enemyRoll}, D:${eDiceRoll}, C:${eCoinBonus})`);

                if (playerRoll >= enemyRoll) {
                    log(`${player.name} wins the clash!`, 'log-win');
                    this.executeAction(player, playerAbility, enemy, pDiceRoll);
                    
                    // Balter Passive Check
                    if (player.uniquePassive?.onClashWin) {
                        UniqueEffectHandlers[player.uniquePassive.onClashWin](player, enemy);
                    }
                } else {
                    log(`${enemy.name} wins the clash!`, 'log-loss');
                    this.executeAction(enemy, enemyAbility, player, eDiceRoll);
                    
                    // Balter Passive Check
                    if (enemy.uniquePassive?.onClashWin) {
                        UniqueEffectHandlers[enemy.uniquePassive.onClashWin](enemy, player);
                    }
                }
            }
        };

        // ----------------- GAME FLOW -----------------
        function executeAbility(ability) {
            if (gameState.playerAction !== null) return;
            gameState.playerAction = ability;
            selectEnemyAction();
            resolveTurn();
        }

        function resolveTurn() {
            const p = gameState.playerAction;
            const e = gameState.enemyAction;
            const player = gameState.player;
            const enemy = gameState.enemy;

            log(`--- Turn ${gameState.turn} ---`, 'log-special');

            // 1. Both attack (Clash Check)
            const pIsAttack = p.type === 'ATTACK' || p.type === 'DYNAMIC_ATTACK';
            const eIsAttack = e.type === 'ATTACK' || e.type === 'DYNAMIC_ATTACK';

            if (pIsAttack && eIsAttack) {
                Combat.handleClash(p, e);
            }
            // 2. Speed Initiative (Attack vs Non-Attack or Attack vs NONE)
            else {
                let [first, second] = (player.baseStats.speed >= enemy.baseStats.speed)
                    ? [player, enemy]
                    : [enemy, player];

                let [firstAbility, secondAbility] = (first === player)
                    ? [p, e]
                    : [e, p];

                // First action
                Combat.executeAction(first, firstAbility, second);

                // Check if second character is still alive AND not staggered/disabled
                const secondIsStaggered = second.baseStats.effects.includes('Stagger');
                if (second.baseStats.currentHP > 0 && secondAbility.type !== 'NONE' && !secondIsStaggered) {
                    Combat.executeAction(second, secondAbility, first);
                } else if (secondIsStaggered) {
                    log(`${second.name} was Staggered and could not act!`);
                }
            }

            endTurnCleanup();
        }

        function endTurnCleanup() {
            // Run pre-turn status resolution (removes Stagger, Defense+, etc.)
            Status.resolveTurnStart(gameState.player);
            Status.resolveTurnStart(gameState.enemy);
            
            // Run character-specific passive turn-end handlers (e.g., Striker's counter)
            if (gameState.player.uniquePassive?.onTurnEnd) {
                const handlerName = gameState.player.uniquePassive.onTurnEnd;
                UniqueEffectHandlers[handlerName](gameState.player);
            }

            // Check for game over (simplified)
            if (gameState.player.baseStats.currentHP <= 0) {
                log(`${gameState.player.name} has been defeated! Game Over.`, 'log-loss');
                dialogueText.textContent = 'GAME OVER';
                actionButtonsDiv.innerHTML = '<button onclick="setView(\'select\')" class="w-full">Restart</button>';
            } else if (gameState.enemy.baseStats.currentHP <= 0) {
                log(`${gameState.enemy.name} has been defeated! You Win!`, 'log-win');
                dialogueText.textContent = 'VICTORY!';
                actionButtonsDiv.innerHTML = '<button onclick="setView(\'select\')" class="w-full">Select New Hero</button>';
            } else {
                gameState.turn++;
                gameState.playerAction = null;
                gameState.enemyAction = null;
                updateHealthUI();
                renderActions();
                dialogueText.textContent = 'Choose your action:';
            }
        }

        function selectEnemyAction() {
            const enemy = gameState.enemy;
            
            if (enemy.baseStats.effects.includes('Stagger')) {
                gameState.enemyAction = { name: 'Staggered', type: 'NONE' };
                log(`${enemy.name} is Staggered and skips its turn.`);
                return;
            }

            // Simple AI: Prefer Piledriver if player is Grappled, otherwise 50/50 attack/defense
            const isPlayerGrappled = gameState.player.baseStats.effects.includes('Grappled');
            const grapple = enemy.abilities.find(a => a.name === 'Grapple');
            const attack = enemy.abilities.find(a => a.type === 'ATTACK');
            const defense = enemy.abilities.find(a => a.type === 'DEFENSE');

            if (isPlayerGrappled && enemy.abilities.find(a => a.name === 'Piledriver')) {
                // If enemy had Piledriver (Goblin doesn't, but future enemies might)
                // Use default attack for now.
                gameState.enemyAction = attack;
            } else if (Math.random() < 0.5 && defense) {
                gameState.enemyAction = defense;
            } else if (attack) {
                gameState.enemyAction = attack;
            } else {
                gameState.enemyAction = { name: 'Wait', type: 'NONE' };
            }

            log(`${enemy.name} chooses ${gameState.enemyAction.name}`);
        }

        // ----------------- UI -----------------

        function updateHealthUI() {
            const update = (entity, ui) => {
                const perc = Math.max(0, (entity.baseStats.currentHP / entity.baseStats.maxHP) * 100);
                ui.hpBar.style.width = perc + '%';
                ui.hpText.textContent = `${entity.baseStats.currentHP}/${entity.baseStats.maxHP}`;
                
                // Display effects
                const effectsText = entity.baseStats.effects.length ? ` (${entity.baseStats.effects.join(', ')})` : '';
                ui.statusText.textContent = `Status: ${entity.baseStats.status || 'Active'}${effectsText}`;
            };
            update(gameState.player, playerStatus);
            update(gameState.enemy, enemyStatus);
        }

        function renderActions() {
            actionButtonsDiv.innerHTML = '';
            
            const isEnemyGrappled = gameState.enemy.baseStats.effects.includes('Grappled');
            
            // Get abilities that are NOT hidden (like the Tri-Sword template abilities)
            const visibleAbilities = gameState.player.abilities.filter(a => !a.isHidden); 

            visibleAbilities.forEach(ability => {
                const btn = document.createElement('button');
                btn.classList.add('combat-btn');
                let displayName = ability.name;

                // --- UI Logic for Balter's Piledriver (Required Status Check) ---
                if (ability.name === 'Piledriver') {
                    // Button is disabled if enemy is NOT Grappled
                    btn.disabled = !isEnemyGrappled;
                    if (isEnemyGrappled) {
                        btn.classList.add('combo-ready'); // Visual indicator
                    } else {
                        btn.classList.remove('combo-ready');
                    }
                }
                
                // --- UI Logic for Zectus's Dynamic Attack ---
                if (gameState.player.id === 'zectus' && ability.isZectusMainAttack) {
                    const currentWeapon = gameState.player.baseStats.triSwordState;
                    displayName = `Tri-Sword: ${currentWeapon}`;
                    btn.classList.add('active-weapon-btn'); 
                }

                // Disable all buttons if action already chosen
                if (gameState.playerAction !== null) {
                    btn.disabled = true;
                }

                btn.textContent = displayName;
                btn.onclick = () => executeAbility(ability);
                actionButtonsDiv.appendChild(btn);
            });
        }


        function renderCharacterSelect() {
            $('char-select-cards').innerHTML = '';
            Characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'char-card card cursor-pointer';
                card.innerHTML = `
                    <h3 class="text-2xl">${char.name}</h3>
                    <p class="text-sm">${char.description}</p>
                    <div class="text-xs mt-2">
                        <p>HP: ${char.baseStats.maxHP} | Def: ${char.baseStats.defense}</p>
                        <p class="font-semibold mt-1">Passive: ${char.uniquePassive.name}</p>
                        <p class="text-xs italic">${char.uniquePassive.effect}</p>
                    </div>
                `;
                card.onclick = () => startCombat(char.id);
                $('char-select-cards').appendChild(card);
            });
        }

        function startCombat(playerId) {
            // Deep clone the character data to ensure stats are reset for a new fight
            const playerTemplate = Characters.find(c => c.id === playerId);
            gameState.player = JSON.parse(JSON.stringify(playerTemplate));
            gameState.enemy = JSON.parse(JSON.stringify(ENEMY_GOBLIN));
            
            gameState.player.baseStats.currentHP = gameState.player.baseStats.maxHP;
            gameState.enemy.baseStats.currentHP = gameState.enemy.baseStats.maxHP;
            
            gameState.turn = 1;
            combatLog.innerHTML = '';
            
            log(`${gameState.player.name} (Lvl ${gameState.player.baseStats.level}) enters the Arena!`);
            log(`Opponent: ${gameState.enemy.name}.`, 'log-special');
            
            // Set UI names
            playerStatus.name.textContent = gameState.player.name;
            enemyStatus.name.textContent = gameState.enemy.name;

            setView('combat');
            updateHealthUI();
            renderActions();
        }

        function setView(view) {
            menuScreen.classList.add('hidden');
            charSelectScreen.classList.add('hidden');
            gameContainer.classList.add('hidden');

            if (view === 'menu') menuScreen.classList.remove('hidden');
            if (view === 'select') charSelectScreen.classList.remove('hidden');
            if (view === 'combat') gameContainer.classList.remove('hidden');
        }

        // ----------------- THEME / SETTINGS -----------------
        function applyTheme(theme) {
            body.className = ''; 
            body.classList.add(`${theme}-theme`);
            localStorage.setItem('gameTheme', theme);
            gameState.currentTheme = theme;
        }

        function toggleSettingsPanel() { settingsPanel.classList.toggle('open'); }


        // ----------------- INITIALIZATION -----------------

        function init() {
            applyTheme(localStorage.getItem('gameTheme')||'default'); 
            setView('menu'); 
            renderCharacterSelect();

            newGameBtn.addEventListener('click', () => setView('select'));

            openSettingsBtn.addEventListener('click', toggleSettingsPanel);
            closeSettingsBtn.addEventListener('click', toggleSettingsPanel);
            
            themeOptionBtns.forEach(btn => {
                btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
            });
        }

        window.onload = init;
    </script>
</body>
</html>
