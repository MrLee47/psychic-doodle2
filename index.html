<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronicles of Heroes: Visualized Combat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    
    <!-- CONSOLIDATED STYLES -->
    <style>
        /* -------------------------------------------------------------------------- */
        /* THEME DEFINITIONS */
        /* -------------------------------------------------------------------------- */

        /* Default (Cream/Fantasy) Theme */
        .default-theme {
            --bg-color: #f7f3e8; /* Cream background */
            --primary-color: #4a2d1e; /* Dark earth tone */
            --text-color: #333;
            --border-color: #8c735d;
            --button-bg: #8c735d;
            --button-hover-bg: #b1937e;
            --status-bar-bg: #e2eaf0;
            --hp-color: #d13d3d;
            --hp-bg: #f5caca;
            --mp-color: #3b82f6; /* Blue */
            --log-special: #047857; /* Darker Green highlight */
            --log-win: #059669; /* Darker Green */
            --log-loss: #b91c1c; /* Dark Red */
            --log-damage: #b45309; /* Dark Orange for damage */
            --arena-bg: #ede9d7;
            font-family: 'Inter', sans-serif;
        }

        /* Retro (Green/Terminal) Theme */
        .retro-theme {
            --bg-color: #1a1a1a;
            --primary-color: #00ff41; /* Neon green */
            --text-color: #00ff41;
            --border-color: #008020;
            --button-bg: #006400;
            --button-hover-bg: #00b300;
            --status-bar-bg: #0a0a0a;
            --hp-color: #ff0000;
            --hp-bg: #330000;
            --mp-color: #00ffff; /* Cyan */
            --log-special: #ffff00; /* Yellow */
            --log-win: #00ff41;
            --log-loss: #ff0000;
            --log-damage: #ff8c00; /* Dark orange */
            --arena-bg: #050505;
            font-family: 'Monospace', monospace;
        }

        /* General Styles */
        * {
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow-x: hidden;
            font-size: 16px;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
        }

        .hidden { display: none !important; }

        /* Card and Container Styles */
        .main-container {
            max-width: 1200px;
            width: 100%;
            height: 90vh;
            display: grid;
            grid-template-columns: 2fr 1fr; 
            gap: 20px;
        }

        /* Status Bar specific styles */
        .hp-bar-container {
            background-color: var(--hp-bg);
            border-radius: 4px;
            overflow: hidden;
            height: 10px;
            margin-top: 5px;
        }

        .hp-bar-fill {
            height: 100%;
            background-color: var(--hp-color);
            transition: width 0.5s ease-out;
        }
        
        .hp-text {
            font-size: 0.9em;
            text-align: right;
            margin-top: 2px;
            color: var(--hp-color);
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px dotted rgba(0, 0, 0, 0.1);
            font-size: 0.9em;
        }
        .log-special { color: var(--log-special); font-weight: 600; }
        .log-win { color: var(--log-win); font-weight: 700; }
        .log-loss { color: var(--log-loss); font-weight: 700; }
        .log-damage { color: var(--log-damage); font-weight: 700; }

        /* The Visual Arena (Left Slot) */
        #visual-arena {
            background-color: var(--arena-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 10px; /* Reduced padding to make room for dialogue */
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Animation Container */
        #roll-animation-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            gap: 20px;
            min-height: 400px;
        }

        .visual-placeholder {
            font-size: 1.5rem;
            color: var(--primary-color);
            opacity: 0.6;
            text-align: center;
        }
        
        /* Combat Panel (Right Side) */
        #combat-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background-color: var(--status-bar-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Dialogue Area Styles */
        #dialogue-area {
            background-color: var(--status-bar-bg);
            border-top: 2px solid var(--border-color);
            border-radius: 0 0 10px 10px;
            padding: 15px;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #room-description {
            font-size: 1.1em;
            margin-bottom: 10px;
            font-style: italic;
        }
        #room-options {
            display: flex;
            gap: 10px;
            justify-content: flex-start;
        }
        
        /* Responsive adjustments for smaller screens */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
                height: auto;
                overflow-y: auto;
            }
            #visual-arena {
                min-height: 400px;
            }
            body {
                padding: 10px;
                height: auto;
            }
        }
        
        /* Custom Animation Elements */

        /* Slot Machine (Dice Roll) */
        .slot-machine-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 3rem;
            font-weight: 900;
            color: white;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--primary-color);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .slot-wheel {
            width: 80px;
            height: 80px;
            background-color: #333;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: 4px solid var(--border-color);
        }

        .slot-result {
            font-size: 4rem;
            color: white; /* Default spin color */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            transition: color 0.1s;
        }
        
        /* Coin Flip Visualizer */
        .coin-visualizer {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .coin {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .coin-head { background-color: gold; color: #333; }
        .coin-tail { background-color: silver; color: #333; }
        
        /* Flip Animation */
        @keyframes flip-animation {
            0% { transform: rotateY(0) scale(1); }
            50% { transform: rotateY(900deg) scale(1.2); }
            100% { transform: rotateY(0) scale(1); }
        }
        .coin-flipping {
            animation: flip-animation 1s ease-out;
        }

        /* Clash Animation */
        .clash-contester {
            font-size: 2.5rem;
            padding: 10px 20px;
            border-radius: 10px;
            margin: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
            min-width: 250px; /* Ensure labels don't jump when numbers change */
            text-align: center;
        }

        .clash-player { background-color: var(--mp-color); color: white; }
        .clash-enemy { background-color: var(--hp-color); color: white; }

        .clash-winner {
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 8px 15px var(--log-win);
        }
        .clash-loser {
            opacity: 0.4;
        }
        
        /* Specific Grapple Clash Styles */
        .clash-grapple-roll {
            background-color: #8a2be2; /* BlueViolet */
            color: white;
        }

        /* Standard Button Styles (Applied to existing elements) */
        button {
            background-color: var(--button-bg);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
            transform: translateY(-1px);
        }
        button:disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .char-card {
            border: 2px solid var(--border-color);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .char-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Settings Panel Fix */
        #settings-panel.open {
            transform: translateX(0);
        }
        
        /* Settings Panel Base (Hidden by default using translate-x-full in HTML) */
        #settings-panel {
            transition: transform 0.3s ease-in-out;
        }

    </style>
</head>
<body class="default-theme flex-col">

    <!-- Menu Screen -->
    <div id="menu-screen" class="min-h-screen flex flex-col items-center justify-center p-4 w-full">
        <div class="container w-full max-w-sm text-center card">
            <h1 class="text-5xl font-extrabold mb-8">Chronicles of Heroes</h1>
            <div class="space-y-4">
                <button id="new-game-btn" class="w-64">New Game</button>
                <button id="load-game-btn" class="w-64" disabled>Load Game</button>
                <button id="open-settings-menu-btn" class="w-64">Settings</button>
            </div>
        </div>
    </div>

    <!-- Character Select Screen -->
    <div id="character-select-screen" class="hidden min-h-screen flex flex-col items-center p-4 w-full">
        <div class="container w-full max-w-4xl card">
            <h2 class="text-3xl mt-4 mb-6">Select Your Hero</h2>
            <div id="char-select-cards" class="grid grid-cols 1 md:grid-cols-2 lg:grid-cols-4 gap-6 w-full">
                <!-- Character Cards Rendered Here -->
            </div>
        </div>
    </div>

    <!-- Combat Arena -->
    <div id="game-container" class="hidden main-container">
        
        <!-- VISUAL ARENA (Left Column) -->
        <div id="visual-arena">
            
            <!-- Animation Container for Rolls, Flips, Clashes -->
            <div id="roll-animation-container">
                <div class="visual-placeholder">
                    Visual Arena for Clash and Dice/Coin Animations.
                </div>
                <!-- Content will be dynamically inserted here -->
            </div>
            
            <!-- Dialogue/Room Description Area -->
            <div id="dialogue-area" class="card">
                <p id="room-description" class="text-color text-lg mb-4"></p>
                <div id="room-options" class="flex gap-4">
                    <!-- Options buttons will be dynamically inserted here -->
                </div>
            </div>
        </div>
        
        <!-- COMBAT PANEL (Right Column) -->
        <div id="combat-panel">
            
            <!-- Status Bars -->
            <div class="flex justify-between space-x-4">
                <!-- Player Status -->
                <div class="w-1/2 card">
                    <h3 id="player-name" class="text-xl mb-2">Player</h3>
                    <div class="hp-bar-container">
                        <div id="player-hp-bar" class="hp-bar-fill" style="width: 100%;"></div>
                    </div>
                    <p id="player-hp-text" class="hp-text">100/100</p>
                    <p id="player-status-text" class="status-text italic text-sm"></p>
                </div>

                <!-- Enemy Status -->
                <div class="w-1/2 card">
                    <h3 id="enemy-name" class="text-xl mb-2 text-right">Enemy</h3>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar-fill" style="width: 100%;"></div>
                    </div>
                    <p id="enemy-hp-text" class="hp-text">80/80</p>
                    <p id="enemy-status-text" class="status-text italic text-sm"></p>
                </div>
            </div>

            <!-- Combat Log -->
            <div class="card flex-grow overflow-y-auto" style="max-height: 40vh;">
                <h4 class="text-lg font-semibold mb-2">Combat Log (Turn: <span id="turn-counter">1</span>)</h4>
                <div id="combat-log" class="flex flex-col-reverse">
                    <!-- Log entries here -->
                </div>
            </div>

            <!-- Action Panel -->
            <div class="card">
                <h4 id="dialogue-text" class="text-lg font-semibold mb-4 text-center">Choose your action:</h4>
                <div id="action-buttons" class="flex flex-wrap gap-3 justify-center">
                    <!-- Buttons rendered here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Panel (Fixed position, hidden by default via transform-x-full) -->
    <div id="settings-panel" class="fixed top-0 right-0 w-80 h-full bg-white shadow-xl p-6 z-10 transform translate-x-full">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-2xl font-bold">Settings</h3>
            <button id="close-settings-btn" class="text-xl">&times;</button>
        </div>
        <div class="theme-selector">
            <h4 class="text-lg font-semibold mb-3">Theme Selection</h4>
            <button class="theme-option-btn w-full" data-theme="default">Default (Cream)</button>
            <button class="theme-option-btn w-full mt-2" data-theme="retro">Retro (Green Terminal)</button>
        </div>
    </div>

    <script>
        /* -------------------------------------------------------\
           Chronicles of Heroes: Consolidated & Modular Core
           ------------------------------------------------------- */

        // ----------------- GLOBAL STATE -----------------
        const gameState = {
            isGameStarted: false,
            currentView: 'menu',
            player: null,
            enemy: null,
            currentTheme: 'default',
            turn: 1,
            playerAction: null,
            enemyAction: null,
            isResolving: false, // Prevents multiple turns
        };

        // ----------------- DOM REFS -----------------
        const $ = (id) => document.getElementById(id);
        const body = document.body;
        const menuScreen = $('menu-screen');
        const gameContainer = $('game-container');
        const charSelectScreen = $('character-select-screen');

        const newGameBtn = $('new-game-btn');
        const loadGameBtn = $('load-game-btn');
        const openSettingsBtn = $('open-settings-menu-btn');
        const settingsPanel = $('settings-panel');
        const closeSettingsBtn = $('close-settings-btn');
        const themeOptionBtns = document.querySelectorAll('.theme-option-btn');

        const dialogueText = $('dialogue-text');
        const actionButtonsDiv = $('action-buttons');
        const combatLog = $('combat-log');
        const turnCounter = $('turn-counter');
        
        const rollAnimationContainer = $('roll-animation-container');
        const roomDescriptionDiv = $('room-description');
        const roomOptionsDiv = $('room-options');


        const playerStatus = {
            name: $('player-name'),
            hpBar: $('player-hp-bar'),
            hpText: $('player-hp-text'),
            statusText: $('player-status-text'),
        };
        const enemyStatus = {
            name: $('enemy-name'),
            hpBar: $('enemy-hp-bar'),
            hpText: $('enemy-hp-text'),
            statusText: $('enemy-status-text'),
        };

        // ----------------- UTILITIES -----------------
        const rollDie = (max) => Math.floor(Math.random() * max) + 1;
        // Returns the count of 'Heads' (1s) from the coin flips
        const rollCoins = (count) => Array.from({ length: count }, () => Math.random() < 0.5 ? 1 : 0)
                                        .reduce((a,b)=>a+b, 0);

        const delayExecution = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function log(message, className='log-entry') {
            const p = document.createElement('p');
            p.className = `log-entry ${className}`;
            p.textContent = message;
            // Prepend to combatLog to show newest message at the top
            combatLog.prepend(p); 
            // Keep the log manageable
            while(combatLog.children.length > 50) combatLog.removeChild(combatLog.lastChild);
        }

        // ----------------- CONSOLIDATED CHARACTER DATA -----------------

        const Characters = [
            // --- 1. Striker (Slow Start: Coin Scaler) ---
            {
                id: 'striker',
                name: 'Striker',
                description: 'A damage specialist who scales in power the longer a fight lasts.',
                baseStats: { maxHP: 110, defense: 2, level: 1, speed: 3, consecutive_rounds: 0, effects: [] },
                uniquePassive: { name: 'Slow Start', effect: 'Each consecutive combat round, gains +1 Coin to all attacks.', type: 'CoinScaler', onClashRoll: 'getStrikerClashBonus', onTurnEnd: 'onStrikerTurnEnd' },
                abilities: [
                    { name: 'Dragon Strike', type: 'ATTACK', damageType: 'Force', baseAttack: 4, dice: 4, coins: 2 },
                    { name: 'Heavy Blow', type: 'ATTACK', damageType: 'Physical', baseAttack: 10, dice: 12, coins: 0, statusApplied: 'Stagger' }
                ]
            },
            // --- 2. Balter (Wrestling Powerhouse) ---
            {
                id: 'balter',
                name: 'Balter',
                description: 'A wrestling powerhouse who locks down targets for massive damage.',
                baseStats: { maxHP: 130, defense: 3, level: 1, speed: 1, grappleDie: 8, isGrappling: false, effects: [] },
                uniquePassive: { name: 'The Old One, Two', effect: 'Roll an extra d4 damage on any successful clash.', type: 'ClashWinBonus', onClashWin: 'getBalterClashWinBonus' },
                abilities: [
                    { name: 'Haymaker', type: 'ATTACK', damageType: 'Blunt', baseAttack: 7, dice: 10, coins: 1 },
                    // Grapple now requires effectHandler to use the new animation/contest logic
                    { name: 'Grapple', type: 'SPECIAL', effect: 'Roll d10 vs target\'s d8. On success, applies Grappled status.', effectHandler: 'executeGrapple', dice: 10, coins: 0, statusApplied: 'Grappled' },
                    { name: 'Piledriver', type: 'ATTACK', damageType: 'Physical', baseAttack: 12, dice: 12, coins: 0, requiredTargetStatus: 'Grappled', postExecutionHandler: 'removeGrappleStatus' }
                ]
            },
            // --- 3. Shuten-Maru (Chrono-Fist) ---
            {
                id: 'shutenmaru',
                name: 'Shuten-Maru',
                description: 'A swift, ghostly fighter who converts damage taken into healing.',
                baseStats: { maxHP: 100, defense: 1, level: 1, speed: 4, lastDamageTaken: 0, effects: [] },
                uniquePassive: { name: 'Chrono-Fist', effect: 'If an attack die roll is 8, heal for the damage taken in the previous turn.', type: 'RollTrigger' },
                abilities: [
                    { name: 'Ghost Fist', type: 'ATTACK', damageType: 'Psychic', baseAttack: 6, dice: 8, coins: 1, postDamageHandler: 'checkShutenMaruHeal' },
                    { name: 'Phase', type: 'DEFENSE', effect: 'Negates the next incoming hit.', effectHandler: 'applyNegateHit', baseAttack: 0, dice: 0, coins: 0 }
                ]
            },
            // --- 4. Zectus Maximus (Tri-Sword) ---
            {
                id: 'zectus',
                name: 'Zectus Maximus',
                description: 'A versatile warrior whose damage type changes with his weapon form.',
                baseStats: { maxHP: 105, defense: 2, level: 1, speed: 2, effects: [], gender: 'Male', triSwordState: 'Scythe' },
                uniquePassive: { name: 'Homogenous', effect: 'Adds +2 Coins to Clashes against female opponents, and doubles damage on clash win.', type: 'ConditionalCoin', condition: { target_gender: 'Female' }, onClashRoll: 'getZectusClashBonus' },
                abilities: [
                    { name: 'Cycle', type: 'SWITCH', effect: 'Cycles Tri-Sword: Scythe -> Trident -> Hammer. Deals 2 damage on activation.', effectHandler: 'cycleTriSword', baseAttack: 2, dice: 0, coins: 0 },
                    // Placeholder ability resolved dynamically
                    { name: 'Tri-Sword: Main Attack', id: 'tri_sword_main', type: 'DYNAMIC_ATTACK', resolver: 'resolveZectusDynamicAttack', dice: 8, coins: 1, isZectusMainAttack: true },
                ]
            },
        ];

        // Enemy Template
        const ENEMY_GOBLIN = {
            id:'goblin', name:'Gravel-Claw Goblin', description: 'A basic enemy with a simple attack and defense.',
            baseStats:{ maxHP: 80, currentHP: 80, defense: 2, speed: 2, status:'Alive', effects: [], grappleDie: 6, gender:'Female' },
            abilities:[
                { name:'Gnaw Attack', type:'ATTACK', baseAttack:5, dice:6, coins:2, damageType:'Physical' },
                { name:'Defensive Crouch', type:'DEFENSE', effectHandler:'applyDefenseBonus', baseAttack:0, dice:0, coins:0 }
            ]
        };


        // ----------------- ANIMATION/VISUAL MODULE -----------------
        const Visuals = {
            async showSlotMachineRoll(diceSize, result, label) {
                rollAnimationContainer.innerHTML = '';
                await Visuals.setDialogue(`Rolling a d${diceSize} for ${label}...`);

                const container = document.createElement('div');
                container.className = 'slot-machine-container';
                container.innerHTML = `<p class="text-xl font-bold mb-2">${label} (d${diceSize})</p>`;

                const wheel = document.createElement('div');
                wheel.className = 'slot-wheel flex justify-center items-center';

                const resultDisplay = document.createElement('div');
                resultDisplay.className = 'slot-result'; 
                resultDisplay.textContent = '...';
                
                wheel.appendChild(resultDisplay);
                container.appendChild(wheel);
                rollAnimationContainer.appendChild(container);

                const spinDuration = 1500;
                const intervalTime = 50;
                let startTime = Date.now();
                
                // Use a Promise to control the animation and delay
                await new Promise(resolve => {
                    let rollInterval = setInterval(() => {
                        if (Date.now() - startTime >= spinDuration) {
                            clearInterval(rollInterval);
                            resultDisplay.textContent = result; // Set final result
                            resultDisplay.style.color = 'var(--log-damage)'; // Final color
                            resolve();
                        } else {
                            // Rapidly cycle placeholder numbers
                            resultDisplay.textContent = Math.floor(Math.random() * diceSize) + 1;
                            resultDisplay.style.color = 'white'; // Spin color
                        }
                    }, intervalTime);
                });

                await delayExecution(1000); // Result display time
            },

            async showCoinFlips(coinCount, result) {
                if (coinCount === 0) return;
                
                rollAnimationContainer.innerHTML = '';
                await Visuals.setDialogue(`Flipping ${coinCount} coin(s) for bonus damage...`);

                const container = document.createElement('div');
                container.className = 'flex flex-col items-center';
                container.innerHTML = `<p class="text-lg font-bold mb-2">Coin Bonus: +${result}</p>`;
                
                const visualizer = document.createElement('div');
                visualizer.className = 'coin-visualizer';

                // Simple visualization: show the final result
                for (let i = 0; i < coinCount; i++) {
                    const coin = document.createElement('div');
                    const isHead = i < result;
                    coin.className = `coin coin-flipping ${isHead ? 'coin-head' : 'coin-tail'}`;
                    coin.textContent = isHead ? 'H' : 'T';
                    coin.style.animationDelay = `${i * 0.2}s`;
                    visualizer.appendChild(coin);
                }
                
                container.appendChild(visualizer);
                rollAnimationContainer.appendChild(container);

                await delayExecution(2000 + coinCount * 200); // Wait for flips
            },

            // Unified function for Clash and Grapple contests
            async showClashAnimation(pRoll, eRoll, isGrapple = false) {
                rollAnimationContainer.innerHTML = '';
                const prompt = isGrapple ? 'Contesting Grapple Attempt...' : 'Contesting the Clash...';
                await Visuals.setDialogue(prompt);

                const container = document.createElement('div');
                container.className = 'flex flex-col items-center justify-center space-y-4';
                
                // Add specific class for grapple roll visuals
                const pContesterClass = isGrapple ? 'clash-grapple-roll' : 'clash-player';
                const eContesterClass = isGrapple ? 'clash-grapple-roll' : 'clash-enemy';
                
                const pContester = document.createElement('div');
                pContester.className = `clash-contester ${pContesterClass}`;
                pContester.textContent = `${gameState.player.name}: ???`;

                const eContester = document.createElement('div');
                eContester.className = `clash-contester ${eContesterClass}`;
                eContester.textContent = `${gameState.enemy.name}: ???`;
                
                container.appendChild(pContester);
                container.appendChild(document.createElement('p')).textContent = 'VS';
                container.appendChild(eContester);
                
                rollAnimationContainer.appendChild(container);

                // Rapid number cycling for Clash
                const spinDuration = 1500;
                const intervalTime = 50;
                let startTime = Date.now();
                const maxClashValue = isGrapple ? 12 : 20; // Use appropriate max value for spin animation

                await new Promise(resolve => {
                    let clashInterval = setInterval(() => {
                        if (Date.now() - startTime >= spinDuration) {
                            clearInterval(clashInterval);
                            
                            // Set final results
                            pContester.textContent = `${gameState.player.name}: ${pRoll}`;
                            eContester.textContent = `${gameState.enemy.name}: ${eRoll}`;
                            
                            // Apply winner/loser classes
                            const winner = pRoll >= eRoll ? pContester : eContester;
                            const loser = pRoll >= eRoll ? eContester : pContester;
                            winner.classList.add('clash-winner');
                            loser.classList.add('clash-loser');
                            
                            resolve();
                        } else {
                            // Rapidly cycle placeholder numbers
                            pContester.textContent = `${gameState.player.name}: ${Math.floor(Math.random() * maxClashValue) + 1}`;
                            eContester.textContent = `${gameState.enemy.name}: ${Math.floor(Math.random() * maxClashValue) + 1}`;
                        }
                    }, intervalTime);
                });

                await delayExecution(1500);
            },
            
            async setDialogue(description, options = []) {
                roomDescriptionDiv.textContent = description;
                roomOptionsDiv.innerHTML = '';
                
                if (options.length > 0) {
                    options.forEach(opt => {
                        const btn = document.createElement('button');
                        // Use button-bg for option buttons
                        btn.className = 'px-4 py-2 text-white rounded-md transition duration-200';
                        btn.textContent = opt.text;
                        btn.onclick = () => {
                            // Disable all options once one is chosen
                            roomOptionsDiv.querySelectorAll('button').forEach(b => b.disabled = true);
                            opt.action();
                        };
                        roomOptionsDiv.appendChild(btn);
                    });
                }
            },
            
            clearAnimations() {
                rollAnimationContainer.innerHTML = `<div class="visual-placeholder">Waiting for next action...</div>`;
            }
        };


        // ----------------- HANDLER MODULE: UNIQUE EFFECT LOGIC -----------------
        const UniqueEffectHandlers = {
            getStrikerClashBonus(attacker) {
                const bonus = attacker.baseStats.consecutive_rounds || 0;
                if (bonus > 0) log(`${attacker.name} passive grants +${bonus} coin bonus to clash roll.`, 'log-special');
                return bonus;
            },
            onStrikerTurnEnd(character) {
                character.baseStats.consecutive_rounds = (character.baseStats.consecutive_rounds || 0) + 1;
                log(`${character.name} grows stronger! Coin Bonus: +${character.baseStats.consecutive_rounds}`, 'log-special');
            },
            applyNegateHit(attacker, ability, target) {
                attacker.baseStats.effects.push('NegateNextHit');
                log(`${attacker.name} phases and will negate the next incoming hit.`, 'log-special');
            },
            checkShutenMaruHeal(attacker, ability, target, diceRoll) {
                // If the dice roll for the attack was an 8
                if (diceRoll === 8) {
                    const heal = attacker.baseStats.lastDamageTaken;
                    if (heal > 0) {
                        attacker.baseStats.currentHP = Math.min(attacker.baseStats.maxHP, attacker.baseStats.currentHP + heal);
                        log(`${attacker.name}'s Chrono-Fist triggers, healing ${heal} HP (Damage Taken: ${heal}).`, 'log-win');
                    }
                }
            },
            getBalterClashWinBonus(winner, loser) {
                const bonusDamage = rollDie(4);
                loser.baseStats.currentHP = Math.max(0, loser.baseStats.currentHP - bonusDamage);
                log(`${winner.name}'s One-Two lands a bonus d4 hit for ${bonusDamage} damage!`, 'log-damage');
                updateHealthUI();
            },
            // Grapple now uses the new visual contest
            async executeGrapple(attacker, ability, target) {
                const rollA = rollDie(ability.dice); // Balter's d10
                const rollT = rollDie(target.baseStats.grappleDie || 8); // Target's d6 or d8

                // 1. Visualize Grapple Contest
                await Visuals.showClashAnimation(rollA, rollT, true); // true for isGrapple
                
                log(`${attacker.name} attempts Grapple (Roll: ${rollA} vs ${target.name} Defense Roll: ${rollT})`);

                if(rollA > rollT) { 
                    target.baseStats.effects.push('Grappled');
                    attacker.baseStats.isGrappling = true;
                    log(`${attacker.name} successfully Grapples ${target.name}!`, 'log-special');
                } else {
                    log(`${attacker.name} fails Grapple on ${target.name}.`);
                }
                renderActions(); // Update action buttons (Piledriver)
            },
            removeGrappleStatus(attacker, ability, target) {
                target.baseStats.effects = target.baseStats.effects.filter(e => e !== 'Grappled');
                attacker.baseStats.isGrappling = false;
                log(`${target.name} is released from Grapple.`, 'log-special');
                renderActions(); // Update action buttons (Piledriver)
            },
            getZectusClashBonus(attacker, target) {
                const isFemale = target.baseStats.gender === attacker.uniquePassive.condition.target_gender;
                if (isFemale) {
                    log(`${attacker.name}'s passive grants +2 Coins vs female opponent!`, 'log-special');
                    return 2;
                }
                return 0;
            },
            resolveZectusDynamicAttack(attacker) {
                const state = attacker.baseStats.triSwordState;
                const subAbilities = {
                    'Scythe': { name: 'Tri-Sword: Scythe', type: 'ATTACK', damageType: 'Necrotic', baseAttack: 6, dice: 8, coins: 1 },
                    'Trident': { name: 'Tri-Sword: Trident', type: 'ATTACK', damageType: 'Physical', baseAttack: 7, dice: 10, coins: 1 },
                    'Hammer': { name: 'Tri-Sword: Hammer', type: 'ATTACK', damageType: 'Force', baseAttack: 8, dice: 12, coins: 1 },
                };

                const resolvedAbility = subAbilities[state];
                log(`${attacker.name} attacks with the ${state} Form. (Type: ${resolvedAbility.damageType})`, 'log-special');
                return resolvedAbility;
            },
            cycleTriSword(attacker, ability, target) {
                const weapons = ['Scythe', 'Trident', 'Hammer'];
                let idx = weapons.indexOf(attacker.baseStats.triSwordState);
                let next = (idx + 1) % weapons.length;
                attacker.baseStats.triSwordState = weapons[next];
                
                const damage = ability.baseAttack || 2;
                // Deal activation damage to the target (enemy)
                target.baseStats.currentHP = Math.max(0, target.baseStats.currentHP - damage);
                
                log(`${attacker.name} cycles to ${weapons[next]} and strikes ${target.name} for ${damage} damage.`, 'log-damage');
                updateHealthUI();
            },
            applyDefenseBonus(attacker, ability, target) {
                attacker.baseStats.effects.push('DefensePlusTwo');
                log(`${attacker.name} takes a Defensive Stance! (+2 Defense)`, 'log-special');
            }
        };

        // ----------------- ABILITY TYPE HANDLERS (ASYNCHRONOUS) -----------------
        const AbilityTypeHandlers = {
            ATTACK: async (attacker, ability, target, diceRoll, context = {}) => {
                
                const damageMultiplier = context.damageMultiplier || 1; // Zectus passive check
                
                if (target.baseStats.effects.includes('NegateNextHit')) { 
                    log(`${target.name} Phases! Negating hit.`, 'log-win'); 
                    target.baseStats.effects = target.baseStats.effects.filter(e => e !== 'NegateNextHit'); 
                    return; 
                }

                // --- 1. Dice Roll Animation (already done in clash, but needed for sequential attack) ---
                if (!context.clashWinner) { // Only animate dice roll if it wasn't part of a clash
                    await Visuals.showSlotMachineRoll(ability.dice || 1, diceRoll, `${attacker.name}'s Attack`);
                }
                
                // --- 2. Coin Flip Logic (ONLY FOR STRIKER'S PASSIVE IN SEQUENTIAL ATTACKS) ---
                let totalCoinsToFlip = 0;
                let coinBonus = 0;

                if (attacker.id === 'striker' && !context.clashWinner) {
                    // Striker's passive grants coin damage bonus outside of Clash (in sequential attacks)
                    totalCoinsToFlip = attacker.baseStats.consecutive_rounds || 0;
                    if (totalCoinsToFlip > 0) {
                        coinBonus = rollCoins(totalCoinsToFlip);
                        await Visuals.showCoinFlips(totalCoinsToFlip, coinBonus);
                    }
                }
                
                // --- 3. Damage Calculation ---
                let defense = target.baseStats.defense;
                if(target.baseStats.effects.includes('DefensePlusTwo')) defense += 2;
                
                // Damage = (Base Attack + Coin Bonus [0 for non-Striker in sequential] - Defense) * Multiplier
                let baseDmg = Math.max(0, (ability.baseAttack || 0) + coinBonus - defense);
                let finalDmg = Math.round(baseDmg * damageMultiplier);

                if (damageMultiplier > 1) {
                    log(`${attacker.name}'s passive doubles damage to ${finalDmg} against ${target.name}!`, 'log-win');
                }

                if (target.id === 'shutenmaru') target.baseStats.lastDamageTaken = finalDmg;

                target.baseStats.currentHP = Math.max(0, target.baseStats.currentHP - finalDmg);
                log(`${attacker.name} attacks with ${ability.name}. Hits for ${finalDmg} (${ability.damageType})`, 'log-damage');
                updateHealthUI();
                await delayExecution(500);

                Status.resolvePostAction(attacker, ability, target, diceRoll);
            },

            DEFENSE: async (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} takes a generic defensive action.`);
                }
                await delayExecution(1000);
            },

            SPECIAL: async (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    // Special abilities (like Grapple) handle their own execution flow
                    await UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } else {
                    log(`${attacker.name} uses a generic special ability.`);
                }
                await delayExecution(1000);
            },
            
            SWITCH: async (attacker, ability, target) => {
                if (ability.effectHandler && UniqueEffectHandlers[ability.effectHandler]) {
                    UniqueEffectHandlers[ability.effectHandler](attacker, ability, target);
                } 
                renderActions(); // Update buttons immediately for weapon change
                await delayExecution(1000);
            },

            DYNAMIC_ATTACK: async (attacker, ability, target, diceRoll, context = {}) => {
                if (ability.resolver && UniqueEffectHandlers[ability.resolver]) {
                    const resolvedAbility = UniqueEffectHandlers[ability.resolver](attacker, ability);
                    
                    // Recursive call to ATTACK handler, passing context
                    await AbilityTypeHandlers.ATTACK(attacker, resolvedAbility, target, diceRoll, context);
                }
            }
        };


        // ----------------- STATUS MECHANICS -----------------
        const Status = {
            resolvePostAction: (attacker, ability, target, diceRoll = null) => {
                if (ability.statusApplied && !target.baseStats.effects.includes(ability.statusApplied)) {
                    target.baseStats.effects.push(ability.statusApplied);
                    log(`${target.name} is inflicted with ${ability.statusApplied}!`, 'log-special');
                }

                if (ability.postDamageHandler && UniqueEffectHandlers[ability.postDamageHandler]) {
                    UniqueEffectHandlers[ability.postDamageHandler](attacker, ability, target, diceRoll);
                }
                
                if (ability.postExecutionHandler && UniqueEffectHandlers[ability.postExecutionHandler]) {
                    UniqueEffectHandlers[ability.postExecutionHandler](attacker, ability, target);
                }
            },

            resolveTurnStart: (character) => {
                // Remove temporary effects like DefensePlusTwo, Stagger
                character.baseStats.effects = character.baseStats.effects.filter(e => 
                    e !== 'DefensePlusTwo' && e !== 'Stagger'
                );
            }
        };

        // ----------------- COMBAT ENGINE (ORCHESTRATOR - ASYNCHRONOUS) -----------------
        const Combat = {
            baseClashValue: 5,

            async executeAction(attacker, ability, target, diceRoll = null, context = {}) {
                if (!ability || ability.type === 'NONE') return;

                if (ability.requiredTargetStatus && !target.baseStats.effects.includes(ability.requiredTargetStatus)) {
                    log(`${attacker.name}'s ${ability.name} failed: Target is not ${ability.requiredTargetStatus}.`);
                    return;
                }

                if (ability.type.includes('ATTACK') && !diceRoll) {
                    // Only roll dice if it's an attack and not already rolled during clash
                    diceRoll = rollDie(ability.dice || 1); 
                }

                if (AbilityTypeHandlers[ability.type]) {
                    // Await the handler for animation completion
                    await AbilityTypeHandlers[ability.type](attacker, ability, target, diceRoll, context);
                } else {
                    log(`ERROR: Unknown ability type: ${ability.type}`);
                    await delayExecution(500);
                }
            },

            async handleClash(playerAbility, enemyAbility) {
                const player = gameState.player;
                const enemy = gameState.enemy;

                // 1. Calculate Coins/Bonus
                let pClashBonus = 0;
                if (player.uniquePassive?.onClashRoll) {
                    const handlerName = player.uniquePassive.onClashRoll;
                    pClashBonus += UniqueEffectHandlers[handlerName](player, enemy);
                }
                let eClashBonus = 0;
                if (enemy.uniquePassive?.onClashRoll) {
                    const handlerName = enemy.uniquePassive.onClashRoll;
                    eClashBonus += UniqueEffectHandlers[handlerName](enemy, player);
                }
                
                // Base coins from the ability itself are ALWAYS added for Clash Roll
                const pCoins = (playerAbility.coins || 0) + pClashBonus;
                const eCoins = (enemyAbility.coins || 0) + eClashBonus;

                // 2. Perform Rolls and Coin Flips for Clash
                const pDiceRoll = rollDie(playerAbility.dice || 1);
                const eDiceRoll = rollDie(enemyAbility.dice || 1);
                
                const pCoinBonus = rollCoins(pCoins);
                const eCoinBonus = rollCoins(eCoins);

                const playerRoll = this.baseClashValue + pDiceRoll + pCoinBonus;
                const enemyRoll = this.baseClashValue + eDiceRoll + eCoinBonus;

                log(`Clash Rolls: P(${playerRoll}, D:${pDiceRoll}, C:${pCoinBonus}) vs E(${enemyRoll}, D:${eDiceRoll}, C:${eCoinBonus})`);

                // 3. Visualize Clash (Awaits animation)
                await Visuals.showClashAnimation(playerRoll, enemyRoll);
                
                let winner, winnerAbility, winnerDiceRoll, loser, damageContext = { clashWinner: true, damageMultiplier: 1 };
                
                if (playerRoll >= enemyRoll) {
                    log(`${player.name} wins the clash!`, 'log-win');
                    winner = player; winnerAbility = playerAbility; winnerDiceRoll = pDiceRoll; loser = enemy;
                    
                    if (player.uniquePassive?.onClashWin) {
                        UniqueEffectHandlers[player.uniquePassive.onClashWin](player, enemy);
                    }
                    
                    // Zectus Passive: Double Damage check
                    if (player.id === 'zectus' && enemy.baseStats.gender === 'Female') {
                        damageContext.damageMultiplier = 2;
                    }
                } else {
                    log(`${enemy.name} wins the clash!`, 'log-loss');
                    winner = enemy; winnerAbility = enemyAbility; winnerDiceRoll = eDiceRoll; loser = player;
                    
                    if (enemy.uniquePassive?.onClashWin) {
                        UniqueEffectHandlers[enemy.uniquePassive.onClashWin](enemy, player);
                    }
                    
                    // Zectus Passive: Double Damage check (Not relevant for the Goblin enemy, but good practice)
                    if (enemy.id === 'zectus' && player.baseStats.gender === 'Female') {
                        damageContext.damageMultiplier = 2;
                    }
                }
                
                // Execute the winning action with the roll result and context
                await this.executeAction(winner, winnerAbility, loser, winnerDiceRoll, damageContext);
            }
        };

        // ----------------- GAME FLOW (ORCHESTRATOR - ASYNCHRONOUS) -----------------
        async function executeAbility(ability) {
            if (gameState.isResolving) return;
            gameState.isResolving = true;
            gameState.playerAction = ability;
            
            // Disable buttons immediately
            renderActions(); 
            
            await selectEnemyAction();
            await resolveTurn();
        }

        async function resolveTurn() {
            const p = gameState.playerAction;
            const e = gameState.enemyAction;
            const player = gameState.player;
            const enemy = gameState.enemy;
            
            Visuals.clearAnimations();
            log(`--- Turn ${gameState.turn} ---`, 'log-special');

            const pIsAttack = p.type.includes('ATTACK'); // ATTACK or DYNAMIC_ATTACK
            const eIsAttack = e.type.includes('ATTACK');

            if (pIsAttack && eIsAttack) {
                // Both attack: Clash
                await Combat.handleClash(p, e); 
            }
            else {
                // One or both is not an attack: Sequential
                let [first, second] = (player.baseStats.speed >= enemy.baseStats.speed)
                    ? [player, enemy]
                    : [enemy, player];

                let [firstAbility, secondAbility] = (first === player)
                    ? [p, e]
                    : [e, p];
                
                let [firstTarget, secondTarget] = (first === player)
                    ? [enemy, player]
                    : [player, enemy];

                // Execute First action (Await the action for visualization). No clash context.
                await Combat.executeAction(first, firstAbility, firstTarget);

                // Check for immediate defeat before the second action
                if (player.baseStats.currentHP <= 0 || enemy.baseStats.currentHP <= 0) {
                     await endTurnCleanup();
                     return;
                }
                
                // Execute Second action if alive and not staggered
                const secondIsStaggered = second.baseStats.effects.includes('Stagger');
                if (second.baseStats.currentHP > 0 && secondAbility.type !== 'NONE' && !secondIsStaggered) {
                    await Combat.executeAction(second, secondAbility, secondTarget); 
                } else if (secondIsStaggered) {
                    log(`${second.name} was Staggered and could not act!`);
                }
            }

            // Final state check and cleanup
            await endTurnCleanup();
        }

        async function endTurnCleanup() {
            // Give a moment for the last action log/HP update to sink in
            await delayExecution(500); 

            // Clear temporary effects
            Status.resolveTurnStart(gameState.player);
            Status.resolveTurnStart(gameState.enemy);
            
            // Run end-of-turn passives
            if (gameState.player.uniquePassive?.onTurnEnd) {
                const handlerName = gameState.player.uniquePassive.onTurnEnd;
                UniqueEffectHandlers[handlerName](gameState.player);
            }
            // (No end turn passive for Goblin enemy in this version)

            // Check for victory/defeat
            if (gameState.player.baseStats.currentHP <= 0) {
                log(`${gameState.player.name} has been defeated! Game Over.`, 'log-loss');
                dialogueText.textContent = 'GAME OVER';
                Visuals.setDialogue(`The mighty ${gameState.enemy.name} has bested you. The quest ends here.`, [
                    { text: 'Start Over', action: () => setView('select') }
                ]);
            } else if (gameState.enemy.baseStats.currentHP <= 0) {
                log(`${gameState.enemy.name} has been defeated! You Win!`, 'log-win');
                dialogueText.textContent = 'VICTORY!';
                Visuals.setDialogue(`You defeated the ${gameState.enemy.name}! What do you do next?`, [
                    { text: 'Loot Corpse (Not implemented)', action: () => log('You search the goblin. Nothing useful found.') },
                    { text: 'Continue to Next Room', action: () => setView('select') } 
                ]);
            } else {
                // Continue to next turn
                gameState.turn++;
                gameState.playerAction = null;
                gameState.enemyAction = null;
                gameState.isResolving = false;
                
                updateHealthUI();
                renderActions();
                dialogueText.textContent = 'Choose your action:';
                turnCounter.textContent = gameState.turn;
                
                Visuals.setDialogue(`The battle continues. Turn ${gameState.turn}.`);
            }
        }

        async function selectEnemyAction() {
            const enemy = gameState.enemy;
            
            if (enemy.baseStats.currentHP <= 0) {
                gameState.enemyAction = { name: 'Dead', type: 'NONE' };
                return;
            }

            if (enemy.baseStats.effects.includes('Stagger')) {
                gameState.enemyAction = { name: 'Staggered', type: 'NONE' };
                log(`${enemy.name} is Staggered and skips its turn.`);
                return;
            }

            // Simple Goblin AI: 50/50 attack/defense
            const attack = enemy.abilities.find(a => a.type.includes('ATTACK'));
            const defense = enemy.abilities.find(a => a.type === 'DEFENSE');
            const isDefensive = enemy.baseStats.effects.includes('DefensePlusTwo');

            if (Math.random() < 0.5 && defense && !isDefensive) {
                gameState.enemyAction = defense;
            } else if (attack) {
                gameState.enemyAction = attack;
            } else {
                gameState.enemyAction = { name: 'Wait', type: 'NONE' };
            }

            log(`${enemy.name} chooses ${gameState.enemyAction.name}`);
        }

        // ----------------- UI -----------------

        function updateHealthUI() {
            const update = (entity, ui) => {
                const perc = Math.max(0, (entity.baseStats.currentHP / entity.baseStats.maxHP) * 100);
                ui.hpBar.style.width = perc + '%';
                ui.hpText.textContent = `${entity.baseStats.currentHP}/${entity.baseStats.maxHP}`;
                
                // Dynamic styling for HP bar based on percentage
                let hpColor = 'var(--hp-color)';
                if (perc < 30) hpColor = '#ff0000'; // Low HP Warning
                else if (perc < 60) hpColor = '#ffbf00'; // Mid HP Warning
                ui.hpBar.style.backgroundColor = hpColor;


                const effectsText = entity.baseStats.effects.length ? ` (${entity.baseStats.effects.join(', ')})` : '';
                ui.statusText.textContent = `Status: ${entity.baseStats.status || 'Active'}${effectsText}`;
            };
            update(gameState.player, playerStatus);
            update(gameState.enemy, enemyStatus);
        }

        function renderActions() {
            actionButtonsDiv.innerHTML = '';
            
            const isEnemyGrappled = gameState.enemy?.baseStats?.effects?.includes('Grappled');
            const currentWeapon = gameState.player?.baseStats?.triSwordState;
            
            const visibleAbilities = gameState.player?.abilities?.filter(a => !a.isHidden) || [];

            visibleAbilities.forEach(ability => {
                const btn = document.createElement('button');
                btn.classList.add('combat-btn');
                let displayName = ability.name;
                let isDisabled = gameState.isResolving;

                // Conditional enabling/disabling
                if (ability.name === 'Piledriver') {
                    isDisabled = isDisabled || !isEnemyGrappled;
                    if (isEnemyGrappled) {
                        btn.classList.add('combo-ready');
                    }
                }
                
                // Zectus dynamic attack name
                if (gameState.player?.id === 'zectus' && ability.isZectusMainAttack) {
                    displayName = `Tri-Sword: ${currentWeapon}`;
                    btn.classList.add('active-weapon-btn'); 
                }

                btn.disabled = isDisabled;
                btn.textContent = displayName;
                btn.onclick = () => executeAbility(ability);
                actionButtonsDiv.appendChild(btn);
            });
        }


        function renderCharacterSelect() {
            $('char-select-cards').innerHTML = '';
            Characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'char-card card cursor-pointer';
                card.innerHTML = `
                    <h3 class="text-2xl">${char.name}</h3>
                    <p class="text-sm">${char.description}</p>
                    <div class="text-xs mt-2">
                        <p>HP: ${char.baseStats.maxHP} | Def: ${char.baseStats.defense} | Speed: ${char.baseStats.speed}</p>
                        <p class="font-semibold mt-1">Passive: ${char.uniquePassive.name}</p>
                        <p class="text-xs italic">${char.uniquePassive.effect}</p>
                    </div>
                `;
                card.onclick = () => startCombat(char.id);
                $('char-select-cards').appendChild(card);
            });
        }

        function startCombat(playerId) {
            const playerTemplate = Characters.find(c => c.id === playerId);
            // Deep copy templates for new game session
            gameState.player = JSON.parse(JSON.stringify(playerTemplate));
            gameState.enemy = JSON.parse(JSON.stringify(ENEMY_GOBLIN));
            
            gameState.player.baseStats.currentHP = gameState.player.baseStats.maxHP;
            gameState.enemy.baseStats.currentHP = gameState.enemy.baseStats.maxHP;
            
            gameState.turn = 1;
            gameState.isResolving = false;
            combatLog.innerHTML = '';
            turnCounter.textContent = gameState.turn;
            
            log(`${gameState.player.name} (Speed: ${gameState.player.baseStats.speed}) enters the Arena!`);
            log(`Opponent: ${gameState.enemy.name} (Speed: ${gameState.enemy.baseStats.speed}).`, 'log-special');
            
            playerStatus.name.textContent = gameState.player.name;
            enemyStatus.name.textContent = gameState.enemy.name;

            setView('combat');
            Visuals.clearAnimations();
            Visuals.setDialogue(`You encounter a hostile ${gameState.enemy.name}! Prepare for Turn 1.`);
            
            updateHealthUI();
            renderActions();
        }

        function setView(view) {
            menuScreen.classList.add('hidden');
            charSelectScreen.classList.add('hidden');
            gameContainer.classList.add('hidden');

            if (view === 'menu') menuScreen.classList.remove('hidden');
            if (view === 'select') charSelectScreen.classList.remove('hidden');
            if (view === 'combat') gameContainer.classList.remove('hidden');
        }

        // ----------------- THEME / SETTINGS -----------------
        function applyTheme(theme) {
            body.className = ''; 
            body.classList.add(`${theme}-theme`);
            localStorage.setItem('gameTheme', theme);
            gameState.currentTheme = theme;
        }

        function toggleSettingsPanel(e) { 
            // Prevents button from being clicked if panel is already resolving state
            if (e) e.preventDefault(); 
            settingsPanel.classList.toggle('open'); 
        }


        // ----------------- INITIALIZATION -----------------

        function init() {
            // Apply theme from storage or default
            applyTheme(localStorage.getItem('gameTheme')||'default'); 
            setView('menu'); 
            renderCharacterSelect();

            newGameBtn.addEventListener('click', () => setView('select'));

            // FIX: Settings menu now correctly toggles the 'open' class
            openSettingsBtn.addEventListener('click', toggleSettingsPanel);
            closeSettingsBtn.addEventListener('click', toggleSettingsPanel);
            
            themeOptionBtns.forEach(btn => {
                btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
            });
            
            Visuals.setDialogue('Welcome to the Chronicles of Heroes. Choose New Game to begin your adventure!');
        }

        window.onload = init;
    </script>
</body>
</html>
